### Topics
- Good in ReactJS (benefits and weak sides)
- React Hooks - benefits, what problem tries to solve
- Latest features of React (17, 18 versions)
- What are the common cases to use HOC?
- React meets the functional programming concepts?
- React application performance? Is there some way to measure the react component rendering time?
- How to deal with JavaScript errors with React?
- What do you know about React Context vs Redux
- React Fiber, Concurrent Mode (for non technical person)
- React Suspense, lazy loading
- What is reconciliation algorithm, how does it work?
- Redux benefits/drawbacks?
- State management tools – how to organize the global state of the app without Redux (the hooks, unstated, mobx or Apollo). 
- What testing strategy do you use?
- How do you handle component reuse?
- When do you use server side rendering and why?
- What state do you put where and why?
- How do you avoid component duplication? (naming)
- How do you handle branding/themes?
- What approach for style scoping do you know?
- How do you handle translations?


### React app performance

#### Measuring
- Profiler API
- Dev Tools Performance panel (based on 1.)
- Lighthouse


### Optimizations
- delaying (lets us skip frequent updates)
- debouncing, throttling (e.g., lodash debounce, throttle)
- memoizing (lets us skip excessive computations)
- useEffect
- useMemo
- lazy initialization
- with function argument of useState
- with the third argument of useReducer
- with a custom wrapper function for useRef
- any third party helpers like lodash memoize
- avoiding reconciliation
- PureComponent, shouldComponentUpdate
- React.memo, the second argument function acts like shouldComponentUpdate
- useMemo, useCallback
- dispatch from useReducer (acts like useCallback)
- immutable data structures let us widely use PureComponent/React.memo with a shallow comparison by default
- reducing overhead
- function components over class components
- using optimized production build
- reducing dependencies, e.g., with partial import
- code-splitting
- SSR, SSG, or isomorphic app for some cases

https://react.dev/learn/render-and-commit#optimizing-performance

### React Fiber Architecture
Starting from React v16.0 Reconciliation algorithm based on Fiber Architecture.

Fibers, are simply the new form of JavaScript objects, representing React Components. Most probably they are sort of wrappers around React Components with some additional features like fiber type, fiber priority and others.

To deal with fibers React teams reimplements sort of browser call stack inside React engine. This allows React to control the orders of execution of fibers, schedule, delay and continue them.

React prioritized fibers and according to priority may use requestAnimationFrame or requestIdleCallback to instruct a browser.

Some popular libraries implement the "push" approach where computations are performed when the new data is available. React, however, sticks to the "pull" approach where computations can be delayed until necessary.

React is not a generic data processing library. It is a library for building user interfaces. We think that it is uniquely positioned in an app to know which computations are relevant right now and which are not.

If something is offscreen, we can delay any logic related to it. If data is arriving faster than the frame rate, we can coalesce and batch updates. We can prioritize work coming from user interactions 
(such as an animation caused by a button click) over less important background work (such as rendering new content just loaded from the network) to avoid dropping frames.

https://github.com/acdlite/react-fiber-architecture

https://legacy.reactjs.org/docs/design-principles.html#scheduling


### React Lifecycle

![image](https://github.com/user-attachments/assets/0abbd7fe-2b9c-4d05-b7f4-9681d3fa5485)

- constructor
- getDerivedStateFromProps
- shouldComponentUpdate
- render
- getSnapshotBeforeUpdate
- componentDidMount
- componentDidUpdate
- componentWillUnmount
#### Obsolete methods
- UNSAFE_componentWillMount
- UNSAFE_componentWillUpdate
- UNSAFE_componentWillReceiveProps

https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/


### Reconciliation
The algorithm React uses to diff one tree with another to determine which parts need to be changed. It is triggered before the re-rendering process starts.

![image](https://github.com/user-attachments/assets/42398855-c3d0-42d4-9e85-702b5a23c0f2)

To transform one tree into another, the "state of the art" algorithms have a complexity in the order of O(n3).

React implements a heuristic O(n) algorithm based on two assumptions:

- Two elements of different types will produce different trees.
- The developer can hint at which child elements may be stable across different renders with a key prop.

#### Conclusions:

- return element of the same type from the same component (to avoid the whole child tree destruction)
- use stable unique keys

### Ways to organize state with React
1. React specific ways
- state object for class component
- setState hook for functional component
- context
- context with useReducer hook
2. React compatible way
- stateless
- Redux
- Apollo
- MobX
- other libraries (Recoil, Akita, etc)


#### Lifting State Up
Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.

#### Context
Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language.

#### Context vs Redux
My personal summary is that new context is ready to be used for low-frequency unlikely updates (like locale/theme). It's also good to use it in the same way as the old context was used. I.e. for static values and then propagate updates through subscriptions.
It's not ready to be used as a replacement for all Flux-like state propagation. --- Sebastian Markbage
