### Topics
- SPA vs MPA pros/cons
- SSR vs CSR vs SSG pros/cons
- Micro-frontends, monorepos
- PWA (features list briefly)
- CSS methodologies: BEM, OOCSS, SMACSS, Atomic CSS, CSS-in-JS, CSS Modules
- Choosing a library vs implementing own solution
- Angular vs React vs Vue vs etc - how to choose the next project framework?
-- community, github stars, repos, forks, components
-- documentation
-- support, new versions
-- popularity trends (npm, google, stackoverflow)
-- learning curve
-- features out of the box
-- scalable for big teams
-- versions backward compatibility
-- native/mobile apps support ?
-- bundle size
-- flexible/opinionated in project structure/configuration
-- ease of integration to existing apps (micro frontends-friendliness)
-- production case studies
-- team background / level of knowledge
-- SSR support


### SSR vs CSR

CSR - With a client-side rendering solution, when the user opens your website, his browser makes a request to the server, and the user gets a response with a single HTML file without any content, loading screen, e.t.c. It’s a blank page until the browser fetches all linked JavaScripts and lets the browser compile everything before rendering the content. If there is some data which needs to be rendered to the page, the client will make a request to the api to take the data and then render it to the page. 
If the client navigates to a different route, the server will not send the page again, instead, the client will re-render the page according to the route that client requested
  
![image](https://github.com/user-attachments/assets/0c0b8dca-26af-49cf-81d9-cd992656afcf)


SSR is not a new concept. It has been used since the first backend solution, like PHP or JAVA. Server-side rendering is a method to render your website. When the user opens your page, his browser makes a request to the server, and the server generates ready to provide HTML. 
When the request is received on the server-side, it compiles everything. Every time the client navigates to a different route, the server will do the work all over again.

![image](https://github.com/user-attachments/assets/e23f5c05-f34d-4910-8d3b-82555a6ae369)

#### Resources:

https://altalogy.com/blog/client-side-rendering-vs-server-side-rendering/

https://medium.com/walmartlabs/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8

https://pagepro.co/blog/ssrvscsr/

https://dev.to/alain2020/ssr-vs-csr-2617

https://www.growth-rocket.com/blog/a-closer-look-at-client-side-server-side-rendering/

| **Критерий**                     | **CSR (Клиентская отрисовка)**                                                                                                                                                                                                                                                   | **SSR (Серверная отрисовка)**                                                                                                                                                                                                                                                                                   |
|-----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Идеально подходит для**         | - SPA (single page application), где не требуется настройка сервера (i18n, роутер и т.д.). <br> - Сайтов с насыщенными интерактивными элементами. <br> - Если сайт почти статический (например, блог, портфолио), можно использовать фреймворки, такие как Gatsby.                                                | - Веб-приложений, где важна SEO, оптимизация для социальных сетей. <br> - Быстрое отображение сайта для пользователя. <br> - Сайтов с низким взаимодействием с пользователем.                                                                                                                                       |
| **Общие преимущества**            | - Быстрая отрисовка после начальной загрузки. <br> - Быстрая навигация между страницами. <br> - Меньшая нагрузка на сервер. <br> - Богатый выбор библиотек JS. <br> - Отлично подходит для насыщенных интерактивных веб-приложений.                                                | - SEO-дружелюбность: страницы легко индексируются поисковыми системами. <br> - Быстрее отображается контент. <br> - Оптимизация для соцсетей: корректное отображение превью (заголовок, описание, изображение). <br> - Возможность совместного использования кода с backend. <br> - Более низкая нагрузка на устройство пользователя. |
| **Недостатки**                    | - Более медленная начальная загрузка. <br> - Непредсказуемая производительность на слабых устройствах или застарелых браузерах. <br> - Проблемы с SEO при неправильной реализации. <br> - Увеличенное потребление памяти.                                                          | - Большее время до первого байта (TTFB), так как сервер создаёт HTML страницы. <br> - Большая нагрузка на сервер, меньшее количество запросов в секунду. <br> - Больший размер HTML документов. <br> - После загрузки страницы она не интерактивна до завершения выполнения JS. <br> - Перезагрузка страницы после смены маршрута. |
| **Скорость**                      | - Нет контента до загрузки всех JS-файлов. <br> - Долгий показ пустой страницы (можно решить с помощью лоадера). <br> - Быстрая реакция при загрузке последующих страниц.                                                                                                       | - HTML загружается быстрее, чем при CSR (приоритет первого контента). <br> - Контент отображается быстрее, но неинтерактивен до завершения выполнения JS. <br> - Более долгое TTFB (Time To First Byte). <br> - Низкий пропуск сервера (особенно для React). <br> - Быстрая загрузка изображений.                     |
| **SEO (Оптимизация для поисковиков)** | - Низкая эффективность для SEO из-за опоры на JavaScript (поисковики плохо индексируют SPA). <br> - Google улучшил индексацию JS, но есть ограничения. <br> - Трудности с индексированием в других поисковиках.                                                              | - Оптимизация страниц под ключевые слова. <br> - Возможность включения мета-тегов на всех страницах улучшает позиции в поисковых системах.                                                                                                                                                                       |
| **Влияние кеширования**            | - После загрузки страницы (без ленивой подгрузки) она может работать без интернета.                                                                                                                                                                                             | - Зависимость от сервера для каждого запроса. <br> - Кеширование может ускорять загрузку, если скрипты берутся из кеша браузера.                                                                                                                                                                                  |
| **Адаптивность под мобильные устройства** | - Непредсказуемая производительность: устройство может быть медленным или использовать устаревший браузер с медленным интернетом.                                                                                                                                             | - Серверная идентификация устройства через строку User-Agent позволяет оптимизировать ответ под его характеристики.                                                                                                                                                                                            |
| **Деплой**                        | - Простота развертывания (один index.html, CSS и JS-бандлы). <br> - Подходит для размещения на статических серверах: Apache, Nginx, Amazon S3, Firebase Hosting и т.п.                                                                                                         | - Сложность развертывания зависит от технологии (например, Magento для e-commerce или Elgg для соцсетей). <br> - Гибридный подход (GatsbyJS, Next.js): первая загрузка через SSR, последующая - через CSR.                                                                                                        |




### BFF

| **Критерий**                 | **REST**                                                                                                                                                                                                                                     | **BFF (Backend for Frontend)**                                                                                                                                                                                                                                                                                                |
|-------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Обзор**                    | - REST используется в качестве общего или универсального backend-сервиса, подходящего для множества целей.                                                                                                                                   | - Если backend-сервис сложный, долгоразрабатываемый и трудный в поддержке, BFF может сократить время и затраты. <br> - Для разных frontend-интерфейсов (например, мобильный и веб) с разными требованиями выгодно использовать BFF для упрощения разработки и поддержки.                                                    |
| **Общие преимущества**       | - REST – универсальное решение, которое легко интегрируется в существующие архитектуры и системы.                                                                                                                                           | - Каждый интерфейс frontend-а может работать со своим BFF параллельно, ускоряя отклик. <br> - Уменьшение сложности модификаций благодаря выделению отдельных backend-сервисов. <br> - BFF скрывает чувствительные или ненужные данные, упрощая архитектуру. <br> - BFF может использовать любой протокол для взаимодействия. |
| **Потенциальные недостатки** | - REST может быть менее гибким для адаптации к нуждам конкретного frontend-а.                                                                                                                                                                 | - Проблема Fan Out: сбой одного BFF может привести к недоступности интерфейса. <br> - Дублирование кода из-за независимой работы команд. <br> - Разные команды (веб, Android, iOS) могут создавать одинаковые правила валидации в своих BFF, увеличивая затраты на разработку.                                                  |
| **Архитектура**              | - REST активно используется для взаимодействия между микросервисами.                                                                                                                                                                       | - BFF рекомендуется использовать в случае, если требуется оптимизация backend-а под специфические frontend интерфейсы. <br> - Возможность решения архитектурных задач с использованием подходов GraphQL или REST.                                                                                                        |




https://2020.stateofcss.com/en-US/technologies/methodologies/

https://martinfowler.com/articles/micro-frontends.html

https://code.tutsplus.com/15-important-considerations-for-choosing-a-web-dev-framework--net-8035t

https://www.altexsoft.com/blog/progressive-web-apps/

  https://css-tricks.com/css-modules-part-1-need/
  
  https://www.toptal.com/front-end/guide-to-monorepos
  
  https://www.browserstack.com/guide/difference-between-progressive-enhancement-and-graceful-degradation
  
