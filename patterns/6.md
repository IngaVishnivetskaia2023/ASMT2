#### Topics
- Design Patterns that you know?
- Creational (several patterns)
- Structural (several patterns)
- Behavioral (several patterns)
- MV*
- Flux/Redux
- Describe the architecture and patterns of your current project, describe challenges?
- JS module systems (ES6+ modules, CommonJS)

#### Links:
- https://refactoring.guru/design-patterns
- https://patterns.addy.ie/
- https://github.com/fbeline/Design-Patterns-JS
- https://hackernoon.com/understanding-solid-principles-in-javascript-w1cx3yrv
- https://www.freecodecamp.org/news/modules-in-javascript/
- https://www.freecodecamp.org/news/anatomy-of-js-module-systems-and-building-libraries-fadcd8dbd0e/


## MV* patterns


### Model View Controller (MVC)
#### Components
The Model refers to the data and business functionality of the application. This is often represented by a Domain Model where objects are used to model real-world entities and processes by representing their properties and behavior.

The View is the visual representation of the Model and is comprised of the screens and widgets used within an application.

The Controller is a component that responds to user input such as data entry and commands issued from a keyboard or mouse. Its responsibility is to act as a bridge between the human and the application, allowing the user to interact with the screen and data.

In Web applications, the View is the content (generally HTML and associated client-side script) returned to the Web client.

Web-based MVC Controllers process delegated HTTP requests (or information derived from the request depending upon the specific implementation).

#### Communication
The Model contains no direct link to the View or Controller and may be modified by the View, Controller, or other objects with the system. When notification to the View and Controller are necessary, the Model uses the Observer Pattern to send a message notifying observing objects that its data has changed.

The View and Controller components work together to allow the user to view and interact with the Model. Each View is associated with a single Controller, and each Controller is associated with a single View. Both the View and Controller components maintain a direct link to the Model.

The View’s responsibility can be seen as primarily dealing with output while the Controller’s responsibility can be seen as primarily dealing with input.

Diagrams

![image](https://github.com/user-attachments/assets/cebf5896-a00a-4925-a3d0-c25f7ea4b364)

### Model View Presenter (MVP)
#### Components
The Model refers to the data and business functionality of the application.

The View is the visual representation of the Model and is comprised of the screens and widgets used within an application.

The Presenter is a component that contains the presentation logic which interacts with the Model.

#### Communication
Both designs are very similar. The key differences are:

The role of handling user input is moved from Controller to the View in MVP.
The Presenter now is mostly a mediator between View and Model. It encapsulates actions into Commands (see The Command Pattern) so they become revokable.

![image](https://github.com/user-attachments/assets/edfd76ee-1a10-46a0-826c-b28be92b27cc)

### Model View View-Model (MVVM)
#### Components
Model refers either to a domain model, which represents real state content (an object-oriented approach) or to the data access layer, which represents content (a data-centric approach).

As in the model–view–controller (MVC) and model–view–presenter (MVP) patterns, View is the structure, layout, and appearance of what a user sees on the screen. It displays a representation of the model and receives the user's interaction with the view (mouse clicks, keyboard input, screen tap gestures, etc.), and it forwards the handling of these to the view model via the data binding (properties, event callbacks, etc.) that is defined to link the view and view model.

View model is an abstraction of the view exposing public properties and commands. Instead of the controller of the MVC pattern, or the presenter of the MVP pattern, MVVM has a binder, which automates communication between the view and its bound properties in the view model. The view model has been described as a state of the data in the model. The main difference between the view model and the Presenter in the MVP pattern is that the presenter has a reference to a view, whereas the view model does not. Instead, a view directly binds to properties on the view model to send and receive updates. 
To function efficiently, this requires a binding technology or generating boilerplate code to do the binding.

![image](https://github.com/user-attachments/assets/4bb5b082-effb-488e-93a4-f5fb67a914d8)


### Model View View-Model Coordinator (MVVM-C)
The MVVM-C pattern is builds upon the MVVM pattern and combines in with the Coordinator pattern.

Coordinator handle navigation within the app by instantiating view controllers (or screens) that are independent and can be reused.

![image](https://github.com/user-attachments/assets/512e20c5-851c-492c-ac19-a412090d7c22)



### View, Interactor, Presenter, Entity, Router (VIPER)
View It's the interface layer, which means UIKit files (including UIViewController). At this point, it's quite clear that UIViewController subclasses should belong to the view layer in a more decoupled architecture. In VIPER, things are basically the same of those in MVVM: views are responsible for displaying what the presenter asks them to, and to transmit user input back to the presenter.

Interactor Contains the business logic described by the use cases in the application. The interactor is responsible for fetching data from the model layer (using network or local database), and its implementation is totally independent of the user interface. It's important to remember that network and database managers are not part of VIPER, so they are treated as separated dependencies.

Presenter Contains view logic to format data to be displayed. In MVVM, this is part of the job done by the ViewModelController in our example. The presenter receives data from the interactor, creates a view model instance and carries it to the View. Also, it reacts to user inputs, asking for more data or sending it back to the interactor.

Entity Has part of the responsibilities of the model layer in the other architectures. Entities are plain data objects, with no business logic, managed by the interactor and by the data managers.

Router The navigation logic of the application. It might not seem an important layer, but if you have to reuse the same iPhone views in a iPad application, the only thing that might change is the way that the views are presented. This lets your other layers remain untouched, and the Router is responsible for the navigation flow in each situation.

![image](https://github.com/user-attachments/assets/33b8b212-ce2d-4fe3-89d2-a7aff91c83ce)

### Links
https://martinfowler.com/eaaDev/uiArchs.html

https://uniandes-se4ma.gitlab.io/books/chapter8/mvc-mvvm-mv-mvwhat.html

https://auth0.com/blog/compare-mvvm-and-viper-architectures/






## Flux/Redux design pattern

### Flux

![image](https://github.com/user-attachments/assets/7d431e6d-00d6-4ff0-81f9-a3eede5afcce)

### Components
- A Single Dispatcher. The dispatcher is the central hub that manages all data flow in a Flux application. It is essentially a registry of callbacks into the stores and has no real intelligence of its own — it is a simple mechanism for distributing the actions to the stores. Each store registers itself and provides a callback. When an action creator provides the dispatcher with a new action, all stores in the application receive the action via the callbacks in the registry.
- Stores. Stores contain the application state and logic. Their role is somewhat similar to a model in a traditional MVC, but they manage the state of many objects. As mentioned above, a store registers itself with the dispatcher and provides it with a callback. This callback receives the action as a parameter. Within the store's registered callback, a switch statement based on the action's type is used to interpret the action and to provide the proper hooks into the store's internal methods. This allows an action to result in an update to the state of the store, via the dispatcher. After the stores are updated, they broadcast an event declaring that their state has changed, so the views may query the new state and update themselves.
- Views and Controller-Views. React (or your favorite lib/framework) provides the kind of composable and freely re-renderable views we need for the view layer. Close to the top of the nested view hierarchy, a special kind of view listens for events that are broadcast by the stores that it depends on. We call this a controller-view, as it provides the glue code to get the data from the stores and to pass this data down the chain of its descendants. We might have one of these controller-views governing any significant section of the page.
- Actions. The dispatcher exposes a method that allows us to trigger a dispatch to the stores, and to include a payload of data, which we call an action. The action's creation may be wrapped into a semantic helper method which sends the action to the dispatcher.


### Redux

![image](https://github.com/user-attachments/assets/4885cdb8-6987-4be4-bad9-d91572c2350c)

#### Components
- Actions. An action is a plain JavaScript object that has a type field. You can think of an action as an event that describes something that happened in the application. Actions may or may not carry a payload (a piece of data).
- Reducers. Reducers are pure functions that take the previous state and an action and return the next state. You can think of a reducer as an event listener which handles events based on the received action (event) type.
-- They should only calculate the new state value based on the state and action arguments
-- They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.
-- They must not do any asynchronous logic, calculate random values, or cause other "side effects".
- Store. The current Redux application state lives in an object called the store. The store is created by passing in a reducer and has a method called getState that returns the current state value. The Redux store has a method called Dispatch. The only way to update the state is to call store.dispatch() and pass in an action object. The store will run its reducer function and save the new state value inside, and we can call getState() to retrieve the updated value
- Selectors. Selectors are functions that know how to extract specific pieces of information from a store state value. As an application grows bigger, this can help avoid repeating logic as different parts of the app need to read the same data.

#### Key principles against a bare Flux
Single Source of Truth. The only way to change the state is to dispatch an action, an object that describes what happened. This way, the UI won't accidentally overwrite data, and it's easier to trace why a state update happened. Since actions are plain JS objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.
State is Read-Only. This makes it easier to debug and inspect your app's state as things change, as well as centralizing logic that needs to interact with the entire application.
Changes are Made with Pure Reducer Functions.
#### Redux drawbacks
- It's, in a nutshell, a global variable, which follows the Singleton pattern and the God Object anti-pattern.
- It scales badly.
- It requires normalization to preserve performance at an appropriate level.
- A lot of boilerplate.
- Overhead for small apps.


https://redux.js.org/tutorials/fundamentals/part-2-concepts-data-flow
https://www.linkedin.com/pulse/mvvm-flux-back-again-andrei-fangli/

