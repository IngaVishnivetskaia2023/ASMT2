### Topics
- tools and techniques for ensuring code quality
- testing pyramid (All types of tests), testing trophy
- Unit Testing vs Integration Testing vs E2E Testing
- effective testing strategy for a simple project?
- which code should be covered with unit tests
- code coverage
- Unit tests (What is good unit test? (FIRST principles) understandable and readable, independent and isolated, repeatable and fast,  should be well structured)
- Integration Testing, Acceptance Testing, API testing, UI testing, e2e tests
- TDD explanation
- code smells
- Code standards and lint rules
- complexity measurement (please check cyclomatic code complexity)
- common tools and metrics for measure code quality
- code review checklist that you follow?
- Code review (What to review and When to review, Code Duplication and how to deal with it)
- Convincing the Customer to write unit-tests
- Typescript advantages and disadvantages
- Process of handling Technical Debt, tools for managing technical debt (ex. Sonar)



#### Code quality metrics

#### Measurement
Here are five of the key traits to measure for higher quality.

- Reliability. It relates to the number of defects and availability of the software. The number of defects can be measured by running a static analysis tool. Software availability can be measured using the mean time between failures (MTBF).
- Maintainability. You can’t use a single metric to ensure maintainability. Some metrics you may consider to improve maintainability are the number of stylistic warnings and Halstead complexity measures.
- Testability. Testability can be measured based on how many test cases you need to find potential faults in the system. The size and complexity of the software can impact testability.
- Portability. Portability measures how usable the same software is in different environments. It relates to platform independence. There isn’t a specific measure of portability.
- Reusability. Reusability can be measured by the number of interdependencies. Running a static analyzer can help you identify these interdependencies.

### Metrics
#### Defect Metrics
- Identification of the stage in which the defect originates.
- Number of open defect reports.
- Time to identify and correct defects.
- Defect density (e.g., number of defects per lines of code).

#### Complexity Metrics
1. Cyclomatic complexity (CYC) is a software metric used to determine the complexity of a program. It is a count of the number of decisions in the source code. The higher the count, the more complex the code.
2. Halstead complexity measures. These measures:
- Program vocabulary
- Program length
- Calculated program length
- Volume
- Difficulty
- Effort

### Code quality gates

![image](https://github.com/user-attachments/assets/0c70f4d4-3a3f-4453-a209-aff1d90cae99)

An example is demonstrated in the picture. We can assure performance, linters, validations of tools like Sonar Cube and other things here.

### The way to improve code quality
1. Use a coding standard.
2. Analyze code — before code reviews (linters).
3. Follow code review best practices.
4. Refactor legacy code (when necessary).


### Links
[What Is Code Quality? And How to Improve Code Quality](https://www.perforce.com/blog/sca/what-code-quality-overview)


### Принципы тестирования F.I.R.S.T.

Принципы `F.I.R.S.T.` описывают характеристики качественных и эффективных автоматических тестов — важно их учитывать при создании тестирования (особенно модульного). 
Аббревиатура `F.I.R.S.T.` расшифровывается как: Fast, Isolated/Independent, Repeatable, Self-validating, Thorough. 
Давайте разберем каждый принцип по отдельности.

1. Fast (Быстрота)
Что это означает: Тесты должны выполняться максимально быстро. Их выполнение должно занимать всего несколько секунд, чтобы разработчик мог запускать их без раздумий.
Почему это важно: Если тесты слишком медленные, разработчики чаще будут избегать их запуска, что снижает ценность тестирования.
Пример: Если тесты выполняются за пару секунд, вы легко можете запускать их после каждого изменения в коде или перед отправкой изменений в систему контроля версий.

3. Isolated/Independent (Изолированность/Независимость)
Что это означает: Каждый тест должен быть полностью независимым от других. Это включает:
Не использование общих данных между тестами.
Отсутствие зависимости от переменных окружения или внешних систем (например, API или базы данных).
Правильное разделение кода теста по паттерну AAA (Arrange, Act, Assert):
Arrange (Подготовка) – Все данные, необходимые для теста, определяются перед его запуском.
Act (Действие) – Вызывается тестируемый метод.
Assert (Проверка) – Проверяется результат работы тестируемого метода. Желательно, чтобы тест проверял только один логический результат, что делает тестирование более точным и предсказуемым.
Почему это важно: Если тесты зависят друг от друга или от внешнего окружения, они становятся ненадежными и сложными для отладки.

5. Repeatable (Повторяемость)
Что это означает: Тесты должны быть детерминированными и давать одинаковый результат при повторных запусках, вне зависимости от:
окружения, в котором они выполняются;
внешних факторов (например, системы, времени, состояния базы данных).
Каждому тесту нужно самостоятельно настраивать свои данные и не полагаться на внешние зависимости.
Почему это важно: Если тесты ведут себя хаотично (успешно в одном случае и проваливаются в другом), сложно доверять результатам тестирования, что подрывает их ценность.

7. Self-validating (Самопроверка)
Что это означает: Тесты должны предоставлять автоматизированный результат: либо тест прошел, либо провалился. Разработчик не должен вручную проверять результат выполнения или интерпретировать сообщения.
Почему это важно: Тесты с автоматической проверкой экономят время и уменьшают вероятность ошибок. Их результат однозначно указывает на статус кода: есть проблемы в тестируемой логике или всё работает корректно.

8. Thorough (Тщательность)
- Что это означает: Тесты должны быть тщательными и охватывать как можно больше сценариев.
- Это включает:
- Проверку всех положительных сценариев ("Happy Paths").
- Тестирование граничных случаев (например, значения "0", минимальные и максимальные возможные значения).
- Тестирование некорректных/нелегальных входных данных (например, пустые строки, null, неверные форматы).
- Проверку безопасности и других потенциальных угроз.
- Проверку, как приложение справляется с большими значениями (например, большие объемы данных или входные параметры).

Не надо гнаться только за 100% покрытием кода — важно проверять реальное поведение функций во всех ключевых сценариях.
Почему это важно: Недостаточное тестирование может привести к тому, что ошибки останутся незамеченными, особенно в редко встречающихся сценариях.

#### Пример, как применять принципы F.I.R.S.T.
Сценарий: Тестирование метода, возвращающего сумму двух чисел.
- Fast: Тест должен выполняться быстро. Например, выполнение функции сложения проходит мгновенно.
- Isolated/Independent: Тест не зависит от базы данных или сетевого подключения. Все данные (пара чисел) предоставляются тесту заранее.
- Repeatable: Результат при любом повторном запуске (например, сумма чисел 2 + 3) всегда будет одинаковым (5).
- Self-validating: Тест будет явно указывать, прошел он или нет, без вмешательства разработчика.
- Thorough: Нужно протестировать следующие случаи:
Стандартные значения (2 + 3 = 5).
Отрицательные числа (-2 + -3 = -5).
Пограничные случаи, например 0 + 0 = 0.
Ошибочные входные данные (например, передача строк вместо чисел).
Почему важно следовать этим принципам?

#### Эти принципы помогают создавать тесты, которые:

Быстро запускаются и повышают производительность команды.
Надежные и стабильные в любых условиях.
Легко читаемые, понятные и не требуют лишних проверок от разработчика.
Уверенно охватывают все основные сценарии кода, включая граничные и редкие случаи.
Тесты, разработанные по F.I.R.S.T., делают процесс тестирования простым, предсказуемым и результативным.
