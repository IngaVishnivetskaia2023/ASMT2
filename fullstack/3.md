## Chapter 3. Building the Data Schema
The data layer covers a lot, so it’s awesome that we have so many good tools to work with. Regardless of the tools you choose, you do need to understand what’s going on beneath the surface. When you start building your data schema, take your time to really write it out. The data schema drives everything for the app and any of its dependencies. Over time, it can become hard to update the schema without breaking everything.

Since you’ve already decided what kind of backend architecture to go with, you probably have an idea of how data will be related and what that data looks like. Making a diagram of how the data will be connected is going to help you and the team a lot because you’ll see the relationships.

That’s why this chapter is going to cover:

- Initial considerations for setting up the data schema

- Setting up a database

- Using object relational mapping (ORM) tools

- Writing data migrations in your database

- Seeding the database with initial data

You want to be as detailed as you can and document as much of the business logic as possible. You’ll also want to get feedback from the team in small intervals because the schema can get complex as the app grows. Make sure everyone understands how and where data is being stored and why. By the time you finish this chapter, you’ll have a good foundation for how to build out your data schema.

### Initial Considerations
To build out your data layer, you’ll go through these basic steps:

- Make a diagram for a data schema. This should include the entities, their columns and data types, and their relationships.

- Set up the database connection in the app. This example will use **Prisma** to connect to a **PostgreSQL** database, but there are other popular tools you can use, such as **Knex.js** or **Drizzle**. Some reasons to use Postgres are because it is open source and has a long history of reliability. You’ll find it behind huge, complex apps that have been in production for decades as well as newer apps that have just been released.

- Write the data schema in the app by translating your diagram into code.

- Add seed data. This is to ensure that your database has the essential data it needs from the beginning. This is also a good way to add data to test in different environments.

- Run migrations. After the connection is established and the schema and seed data is ready, you need **to run a migration to get these changes to the database**.

- Test the database with simple SQL queries. Check that the tables are creating, updating, and storing data as expected. Double-check the relationships between tables by looking at primary and foreign keys.

Some apps will have a more complex scenario than this, but you’ll see a process similar to this across all projects. You already know what data you’re expecting based on your conversations with Product, so now it’s time to make a good diagram for the dev team.

#### Note
We’re not going to discuss nonrelational databases in this book because we’re going to work with relational databases. Relational databases enforce strict rules between data whereas nonrelational databases don’t. Choosing between the two depends on the type of project you’re working on. If you want somewhere to store any format of data that comes in, such as with events that may have constantly changing information, nonrelational databases can give you more flexibility. Nonrelational databases have specific use cases, but many apps are fine with a normal relational database.

### Diagramming the Data Schema
A diagram is a great visual reference for developers and QA to understand what values to expect and why. It’s a good tool to spark discussions between the frontend and backend developers and to document relations between data in a noncode way. Again, these diagrams don’t have to be anything fancy. Developers tend to get hung up on little details in places that don’t matter, such as diagramming tools and image formats. You have to be self-aware enough to notice when you start diving too deep on a task that doesn’t need that much attention.

Your diagram can be simple as long as it has the tables, columns, data types, and relationships between tables. When possible, you want to use a tool that connects directly to the database to create the visualization, such as **DBeaver**. That way, you can see the exact relationships you’ve defined. Or you can continue using Miro to keep all your architectural documentation in one place. The important thing is that it’s in a format that everyone can understand.

Figures 3-1, 3-2, and 3-3 show what some of the documentation for different tables can look like and how they can relate to one another.

<img width="433" height="310" alt="image" src="https://github.com/user-attachments/assets/57ffea87-866b-4705-8b49-aa1f0c71b687" />

<img width="457" height="369" alt="image" src="https://github.com/user-attachments/assets/38373461-e933-4d11-a72d-35a530b3214d" />

<img width="428" height="369" alt="image" src="https://github.com/user-attachments/assets/e9abead3-a0f5-4129-8baf-9595c8efb523" />

In Figure 3-4, you can see how all the tables are related to one another.
<img width="600" height="154" alt="image" src="https://github.com/user-attachments/assets/5808eb73-e02a-4cd9-adfd-263b4dd55518" />


Now that you have documented the data schema, you’ll take this to the team, walk through what your thoughts are, and ask for feedback. The frontend devs may have specific data-format requests based on how they have to render elements. When it comes to the frontend, you typically shouldn’t plan the schema around it. It’s important to make sure that the queries the frontend makes, like searches and sorts, are thought of in the endpoint response, though. Other devs may bring up security considerations.

When you open this up for everyone to think about, you end up with a stronger schema than if one person handled it alone. You’ll learn how to be more confident with sharing your ideas and getting others to share theirs. Don’t be afraid to be wrong during these discussions because that might spark an idea for someone else.

This can be an uncomfortable place for a while because it feels like everyone is heavily scrutinizing your code and your technical skills when they aren’t. You have to get used to receiving constructive feedback; that’s what will help you and the team build better code. The more you present your code and thoughts to the team, the quicker you’ll be able to improve things for everyone.

With the data schema diagrammed and agreed on by the frontend and backend devs, you can start work on connecting the backend to the database to create the tables. You’ll be working with a Postgres instance locally, but this can also be hosted on a server in the cloud.

### Setting Up Postgres
You need to set up Postgres so that you can get the connection information for your app. This will normally be handled by the team that manages the infrastructure for your production and nonproduction environments. You’ll still need your own local instance to make sure the changes that you and the team are making work as expected. This is something you’d include in a Docker container if that’s how you want to keep the local environments consistent. Something else you’re responsible for thinking about is how to make onboarding smooth for new devs. Getting the local environment set up is one of the biggest hurdles for anyone joining a new team, so doing this will pay off as the team and the product grow.

You can download Postgres for free. Follow the documentation to get everything up and running and set a master password. Doing some basic database security locally can help reveal potential issues early because you’ll already be thinking about a production environment. Once `pgAdmin` has finished installing, open the app to create a new database. Then click the PostgreSQL 14 drop-down menu and right-click Databases. This will give you the option to create a new database that you’ll name dashboard. It will look similar to Figure 3-5 when you’re done.

<img width="600" height="303" alt="image" src="https://github.com/user-attachments/assets/e5607f2f-6a2d-48d9-8d6e-88297c1e62bc" />


After you have the new dashboard database, you’ll need to remember the database **name**, database **password**, **port number**, and database **username** to set up the connection to the backend. Unless you choose something other than the default values, some of your credentials will be the following:
```
Database username: postgres

Database port number: 5432
```
Now you’re ready to start creating the tables you diagrammed earlier. You can move on to using an ORM tool to connect the backend to the database and make sure everything’s set up correctly.

#### Basic SQL Queries
It’s good to know some basic SQL commands. You don’t have to get super in-depth with things like views and indexing, but knowing enough to do create, read, update, and delete (CRUD) operations goes a long way. One way to get started is by writing a statement to insert a new row into a table. You can do that with the following SQL:
```
INSERT INTO table_name (column1, column2, column3) VALUES (value1, value2,
  value3);
```


Change table_name to the table you want to insert the data into. The `column1`, `column2`, and `column3` fields represent the column names you want to put the data into. Finally, `value1`, `value2`, and `value3` are the values you want to add to the respective columns. For testing purposes, you can add new row entries like this:
```
INSERT INTO Orders (id, name, total)
VALUES (4, 'Mark', 25.99)
RETURNING id;
```

To check that your data is stored like you expect it to be, you can query the data like this:
```
SELECT * FROM Orders;
```

To round things out, you may need to delete some data to clean up an example you’ve been working on. You can do that with something like this:
```
DELETE FROM Orders
WHERE id = 4
RETURNING *;

```

If you can confidently use commands like these, you have enough SQL knowledge to double-check values directly in the database. Of course, you can dive deeper into SQL with resources like SQLBolt or LearnSQL.com, but you don’t need to.

#### Deciding What ORM to Use
Aside from choosing the framework for your backend, choosing the **ORM tool** is one of the big decisions you’ll make for the future of your project. It’s not an easy task to switch to a different ORM tool once you’ve started building. **NestJS** comes with **TypeORM**, **Sequelize**, and **Mongoose** built in if you don’t have a preference. Other common ORM tools that you’ll be using include **Knex.js** and **Prisma**.

All these tools essentially do the same thing but with a different flavor. Choosing the one you and the team use will come down to everyone’s experience and comfort level as well as any limitations the tools may have. For this project, you’ve decided to go with Prisma because it’s the tool everyone on the team has used before, the documentation is well maintained, and tech teams across different projects in the industry use it. There’s a built-in ORM for NestJS, but Prisma has more support and a bigger community, and it works really well with Postgres. These reasons make it a strong candidate, which is why you and the team have selected it.

Now you’ll need to install Prisma and TSX as dev dependencies in your project with the following command:
```
npm install prisma @prisma/client tsx --save-dev
```

#### Note
There are some finer details you need to be aware of, especially concerning dependencies. When you’re adding a dependency to your project, make sure you understand what type of dependency it needs to be. There are three types of dependencies: dependencies (regular), development (dev) dependencies, and peer dependencies. **Dependencies are the packages your app needs to run after it’s been built for production**. Dev dependencies are the packages you need to do development work, like testing and linting, but they aren’t required for the app to work. You’ll learn more about peer dependencies if you work on a project that needs to be published as its own package, but they are the packages that your package expects to be installed in a container app.

With Prisma installed in your project, you need to set up some configs to connect the app to your Postgres database. As with any ORM, you have to initialize it in your project. With Prisma, you can run the following command to do that. Remember, this output is an example of what you might see, and it could have changed with the latest version:
```
npx prisma init --datasource-provider postgresql

✔ Your Prisma schema was created at prisma/schema.prisma
  You can now open it in your favorite editor.

warn You already have a .gitignore file. Don’t forget to add `.env` in it to not
  commit any private information.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If
  your database has no tables yet, read https://pris.ly/d/getting-started
2. Run prisma db pull to turn your database schema into a Prisma schema.
3. Run prisma generate to generate the Prisma Client. You can then start
  querying your database.

More information in our documentation:
https://pris.ly/d/getting-started
```

This will create the prisma directory and a `.env` file in your project. Make sure the `.env` file is in your `.gitignore` first. Then, inside the prisma directory, you’ll find `schema.prisma`, which is where you’ll set up your database connection and the models for the app. The `.env` file has a URL to your database, which is the connection string that will contain the database credentials. Update the value for `DATABASE_URL` in the `.env` file with your local credentials. It might look something like this:
```
DATABASE_URL="postgresql://username:password@localhost:5432/dashboard"
```

Any values in your `.env` should be handled in your CI/CD pipeline. Work with the DevOps team to get this in place depending on the infrastructure setup. Here’s a simple example of what that might look like with GitHub Actions:
```
name: Node.js CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

env:
  DATABASE_URL: ${{ secrets.ProdDatabase }}

jobs:
  build:
    runs-on: ubuntu-latest
…
```

Now you can move over to the `schema.prisma` file and start writing your model. You’ve already done the hard part of thinking out how everything relates, so now you can confidently start coding. You’ll notice this is where you can see one of the biggest differences between the ORM tools. Prisma has its own flavor that you’ll have to get used to, and you should refer to the docs often.

In your `schema.prisma`, you can start adding pieces of your model. Add the following code to the end of the file:
```
// schema.prisma
…
model User {
  id          Int      @id @default(autoincrement())
  email       String   @unique
  name        String
  address     String
  orders      Order[]
}

model Order {
  id              Int       @id @default(autoincrement())
  total           Float
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  products        Product[]
  userId          Int?
  User            User?     @relation(fields: [userId], references: [id])
}

model Product {
  id              String   @id @default(uuid())
  name            String
  price           Float
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  orders          Order[]
}
```

These models represent the three tables you diagrammed earlier and their relationships. Building models with Prisma is similar to writing objects or type definitions with TypeScript. These models use special Prisma syntax for the types, but they match closely to the common types you work with. The most important thing to note is how relationships are defined between tables. On the Product table, there’s an associated userId. On the User table, we have an array of orders. This is how Prisma defines relationships between tables, and I highly encourage you to look through the documentation to learn about building more complex relationships.

You might also want to consider using the Prisma VS Code plug-in to help make development smoother. For this app, though, these few models will get you moving.

This completes the data schema for your app so far. Now it’s time to get this schema onto the database with a migration.

#### Writing Migrations
Migrations are **the SQL queries made by the ORM based on your schema definition**. When you connect to the database to run a migration, you’re essentially **executing SQL statements**. That’s what makes ORM tools so useful. Instead of having to manually write the SQL for multiple tables, you can write the query in TypeScript, and the ORM will translate it to SQL. JavaScript developers use these tools so that they don’t have to learn all the details of SQL and database quirks. Running a migration is also how you will **check that your database is connected to your backend correctly**. To run a migration with Prisma, you’ll open your console, navigate to the root of the project, and run this command:

```
prisma migrate dev --name initialize_dashboard_db

Environment variables loaded from .env
Prisma schema loaded from prisma/schema.prisma
Datasource "db": PostgreSQL database "dashboard", schema "public" at
  "localhost:5432"

Applying migration `20230318132006_initialize_dashboard_db`

The following migration(s) have been created and applied from new schema changes:

migrations/
  └─ 20230318132006_initialize_dashboard_db/
    └─ migration.sql

Your database is now in sync with your schema.
```

After the migration is successful, check your Postgres instance. You should see these tables and their columns populated in your dashboard database. Check that the tables have the columns you defined in your models. You should also see a new table called `_OrderToProduct` that defines the relationship you created between the `Order` and `Product` tables in your model. This is the fastest way to determine if your database connection is established. The migration would have failed if the connection didn’t exist, but looking directly at the database lets you know everything is fine.

Anytime you update your schema, you’ll need to make a new migration to update the database. Make sure to give it a descriptive name so that you can quickly understand what happened in the database history. This is super helpful if you run into data issues on the backend because it’s easier to see what changes have been made and when. Every migration will automatically generate the timestamp at the beginning of the folder name in Prisma. The timestamp is important for the database to know in what order to run the migrations when someone is trying to set up the database initially.

Other tools will handle migrations a little differently. Knex.js, for example, lets you write migrations in pure SQL if you want, and it generates migration files instead of folders. If you look in your project’s prisma directory, you should see a migrations folder with a subfolder. This is where the generated SQL for your migrations are. That’s the beauty of an ORM. You can write in syntax you’re familiar with, and it will generate the SQL for you. Take a look at the `migration.sql` file in the `migration` folder. You’ll see something like this:

```
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "address" TEXT NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);
…

```

This is just the initial setup migration for the database. You’ll be adding more tables and columns and changing names as the app grows. When you run into issues with a migration, **you can roll it back**; turn to the Prisma docs to learn how to do that. For now, you have what you need to add some seed data to the database so that you can start working on the rest of the app.

#### Seeding the Database
Since this is your local database, you’ll eventually need some test data to play with. You can add that as part of the dev `.env` setup and have it as part of the setup for the real database. To start, create a new `seed.ts` file in the `prisma` directory. This is where you’ll use the Prisma Client to create some records. In your `seed.ts` file, add the following code:

```
// seed.ts
const { PrismaClient } = require('@prisma/client');
const db = new PrismaClient();

const main = async () => {
  const orderData = [...Array(10)].map(() => ({
    id: faker.number.int({ min: 10, max: 170 }),
    total: faker.number.float({ min: 7, max: 15657, precision: 0.01 }),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
    userId: 5,
  }));

  const productData = [...Array(10)].map(() => ({
    id: faker.lorem.word(),
    name: faker.commerce.productName(),
    price: faker.number.float({ min: 35, max: 1055, precision: 0.01 }),
    createdAt: faker.date.anytime(),
    updatedAt: faker.date.anytime(),
  }));
…

```

The complete `seed.ts` file can be found on GitHub.

This code allows you **to connect to the database and insert the new rows into their respective tables**. Then, it disconnects from the database. To run this with Prisma, you need to add the seed config to your `package.json` like this:

```
…
"collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory”: "../coverage",
    "testEnvironment": "node"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  }
}
```

This tells Prisma **where to look for your seed file and how to execute it**. With the configs and some data ready, you can run this command to actually insert the data into your Postgres instance:

```
npx prisma db seed

Environment variables loaded from .env
Running seed command `ts-node prisma/seed.ts` ..

 The seed command has been executed.
```

If you look in your Postgres tables (see Figure 3-6), you should see the values you wrote in `seed.ts`. This should be everything you need for your data concerns right now. Just to double-check, here’s a quick checklist you can go through when you think you’re finished setting everything up:

- Does the schema match the designs and functionality explained in the behavioral doc?

- Have you had at least one other dev look at it?

- Have you checked to make sure the schema works for all the apps consuming data from this database?


There are more advanced things to consider as well that are out of scope for this book. Here’s a list of some of them and links to more resources:

- Does your schema give room for the app to grow?

Software Architecture: The Hard Parts by Neal Ford, Mark Richards, Pramod Sadalage, and Zhamak Dehghani (O’Reilly)

- Is there a way to audit actions and the users who triggered them?

“What Is an Audit Trail? Everything You Need to Know” (Auditboard)

- Have you considered different user-role levels for table operation access?

“Role-Based Access Control (RBAC)” (Imperva)

These advanced topics could have their own chapters or even entire books dedicated to them. There are a wide range of questions you can ask here, but to keep things moving forward at this stage, don’t get too deep into the details. If you can answer these questions, explain the schema decisions to another dev, and demo it to the Product team, you’re good to go for now.

Take notes and make tickets for any optimizations you see along the way. That way, you can come back and actually work on the details because it’s documented in a way that Product considers during sprint planning. You’ve decided that the schema is in a good place and the tickets regarding different endpoints can be unblocked. This is when you’ll start working on the API that different apps will interact with to get data from the database you just set up.

## Conclusion
In this chapter, you went through the process of drawing diagrams for your data, setting up a Postgres instance, and handling some initial setup with your ORM. You should feel pretty good about expanding your data schema from here because you’ve already answered a lot of questions about the future of the app.











