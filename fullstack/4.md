## Chapter 4. REST APIs
With the data schema defined, it’s time to get into the details of exposing that data. You’ll build an API with multiple endpoints that perform various operations, such as getting all the orders or submitting new ones. This is one area of the backend where we’ll get very into the details.

To create an API that can be maintained by different developers as the team changes, you need standard conventions for the team. Standard conventions are usually outlined in a document that defines the way the team agrees to approach code implementation, ranging from everything to naming conventions to the error codes and messages used in responses.

This set of conventions will make it easier to check for deviations in PR reviews for any code changes. Your PRs are changes you submit for other developers to review before they get merged with the central code and deployed. Since there may be multiple PRs for a piece of functionality, this rule enforcement is important for maintaining code consistency across codebases.

This chapter will go over how to address this convention while actually building an API, covering these areas:

- Working through data formatting with the frontend and other consuming services

- Writing an example of code conventions

- Writing the code for the interface, service, and controller for the API

- Tracking errors with logs and custom error handlers

- Ensuring that validation is in place

These are some of the concerns that will come up as you build out your API and the different endpoints. You’ll run into a lot of different approaches to API development and architecture decisions, and most of them are valid. As with everything else, it depends on the needs of your project and the team’s preferences.

For this API, we’re going to follow these conventions:

- It will send and receive data in JSON format.

- Endpoint logic shouldn’t reference other endpoints to keep separation of concerns.

- Use endpoint naming to reflect relationships of data and functionality (e.g., /orders/{orderId}/products).

- Return standard error codes and custom messages.

- Version the endpoints to gracefully handle deprecation.

- Handle calculations, pagination, filtering, and sorting on the backend.

- All endpoints receiving data should have validation.

- Endpoint documentation should be updated with all changes.

#### Making Sure the Frontend and Backend Agree
There is always a partnership between the frontend displaying data and the backend processing it. When the frontend has to make multiple calls to fetch data, that can make the view render more slowly for a user. When the backend sends more data in responses, that can lead to unnecessary information being gathered and sent, which makes the response take longer. This is a trade-off you have to balance.

Typically, any type of pagination, filtering, sorting, and calculations should happen on the backend. This is because you can handle the data more efficiently on the backend compared to loading all the data on the frontend and making it do these operations. It’s very rare that you’ll ever want to load all the data for an app on the frontend. Generally, the engineers work together to come up with a way to handle data that provides a good UX.

This might mean introducing a microservice into the architecture to help both the frontend and backend performance. If there’s a specific endpoint that is called much more than the others, it’s worth researching if it makes sense to separate it out into a microservice and what type of work that would involve.

One area where you might have to push back is how endpoints send data to the frontend. For the frontend, it may make more sense for multiple pieces of data to get sent back on the same endpoint to help with performance and reduce the number of calls made. If it crosses data boundaries, then you need to double-check if the data should be combined. **Data boundaries are how we keep a separation of concerns between different functionalities.** 

Figure 4-1 is an example of keeping a boundary between any products and orders calls.

<img width="600" height="276" alt="image" src="https://github.com/user-attachments/assets/7140bfdb-a84d-4c5c-ab40-0f9696c17cc3" />

Remember, the frontend can filter the data out in the view, but anyone can check the developer tools in the browser to check the network response. It’s always the responsibility of the backend to enforce security when it comes to data handling. The frontend can have some security implemented, but users can bypass the UI and use the endpoints directly. We’ll address some security concerns in Chapter 8, but this is one reason why you want to enforce data boundaries.

Now that the engineers understand the expectations of the frontend and backend, let’s work on the conventions doc for the backend.

#### Creating a Document for Conventions
You can tighten up your code conventions even more with a doc that you share with the team and use to help new devs onboard with the team’s code style. This doc will evolve over time as you encounter new scenarios. It serves as a resource for the team when a new endpoint or even a new API needs to be created. That way, everyone knows how to build the code so that consistency is maintained everywhere.

Tools like Prettier, ESLint, EditorConfig, and Husky can help you automatically enforce the conventions with every PR. Sometimes, nitpicks like spacing, tabs, quotation marks, and tests can get tedious to check for manually. Using these types of tools requires devs to meet the conventions before a commit can even be made. Now every PR will have these little checks, which makes reviews faster and code more consistent.

The following are examples of some conventions:

- Microsoft Azure: RESTful Web API Design

- Google JavaScript Style Guide

- Airbnb JavaScript Style Guide

Docs like these can be starting points for your in-house conventions that you extend to match team preferences. For example, your conventions doc might contain an additional section like the following:

For pagination, responses should return this structure:

```
{
 "page": [
    {
      "id": 4,
      "first_name": "My first name",
      "last_name": "My last name",
      "email": "myemail@server.com"
    },
    {
      "id": 5,
      "first_name": "My first name",
      "last_name": "My last name",
      "email": "myemail@server.com"
    },
    {
      "id": 6,
      "first_name": "My first name",
      "last_name": "My last name",
      "email": "myemail@server.com"
    }
 ],
 "count": 3,
 "limit": 3,
 "offset": 0,
 "total_pages": 4,
 "total_count": 12,
 "previous_page": 1,
 "current_page": 2,
 "next_page": 3,
}
```

For error handling, responses should return this structure:

```
{
  "errors": [
    { "statusCode": "111", "message": "age must be an int" },
    { "statusCode": "112", "message": "email is mandatory" }
  ]
}

```


This is another way you can get feedback from others and make the convention doc the best it can be for everyone.

#### Note
Some things that you’ll set in your conventions will be annoying to stick to sometimes, especially during a time crunch. That’s why it’s important to implement a few features and see how things go in practice before you really enforce conventions through linting and other scripts. Once your conventions are in a good place, though, don’t deviate from them unless there’s a significant change to the direction of the project. The consistency throughout your codebases is what will make projects easier to maintain over the long term.

#### Making the API and First Endpoint
As discussed in Chapter 2, NestJS is the framework you’ll build with. We won’t go through writing all the code tutorial-style here. I’ll address underlying reasons for why functionality is implemented a certain way. This is the type of thinking that spreads to any framework. I’ll leave it up to you to look through the NestJS docs to understand the syntax of the code.

There are so many things to consider when you start coding on the backend. The secret is to just pick an area and focus on it first. You’ll come back through and address security, performance, and testing concerns. For now, though, you need to get some endpoints working, so the frontend can start connecting the UI to the API. You’ll start by writing the basic CRUD operations you know the app will need. In this project, you’ll need CRUD endpoints for:

- Managing products

- Managing orders

- Administrative functions

The first two sets of endpoints are based on what you already know about the app. The last set of endpoints will come from other discussions with Product. There will be actions the Support team will need access to that no user should ever be able to touch. You’ll learn how to handle these different user permission levels and access control in Chapter 8. Remember, these endpoints will likely change. The main thing is that you have to start building somewhere.

#### Tip
You can delete some of the boilerplate files, specifically `app.controller.spec.ts`, `app.controller.ts`, and `app.service.ts`. Also go ahead and update `app.module.ts` to remove the references to those files. This is to keep things as clean as possible as you start to make changes and add new code. Those files are just there as examples of how to implement endpoint functionality. It’s normal to remove some of the example files when you use a scaffolding tool so that you only have what you need. This is something that will come from experience as you work with scaffolding tools and start to understand which files can be removed and which ones are useful starting points.

#### Creating the Orders Endpoints
You can start by working on the functionality for orders. In the src directory, make a new subfolder called orders and add the files to handle the types for this endpoint, the tests, the service, and the controller.

The `orders.controller.ts` file is where you define all the endpoints for this specific feature. You can learn more about how controllers work in the NestJS docs. So anytime you need to fetch orders or make changes to them, the frontend will reference the endpoints here. This is a great place to do your initial validation on data received in requests. Here’s an example of an endpoint:


```
// orders.controller.ts
…
@Get()
  public async orders(): Promise<Array<Order>> {
    try {
      const orders = await this.ordersService.orders({});
      return orders;
    } catch (err) {
      if (err) {
        throw new HttpException('Not found', HttpStatus.NOT_FOUND);
      }
      throw new HttpException('Generic', HttpStatus.BAD_GATEWAY);
    }
  }

```

Here you can see some custom error handling, and it sends a message and status code like you defined in the conventions. The controller shouldn’t contain any business logic because that will be handled in your service. Controllers are just there to handle requests and responses. This makes the code more testable, and it keeps the code separated based on what it should do.

Controllers will also do some of that validation I mentioned. Let’s take a look at an endpoint that will update orders:
```
// orders.controller.ts
…
@Patch(':id')
public async update(
  @Param('id', ParseIntPipe) id: number,
  @Body() order: UpdateOrderDto,
): Promise<Order> {
  try {
    return await this.ordersService.updateOrder({
      where: { id },
      data: order,
    });
  } catch (err) {
    if (err) {
      throw new HttpException('Not found', HttpStatus.NOT_FOUND);
    }
    throw new HttpException('Generic', HttpStatus.BAD_GATEWAY);
  }
}

```

Note how the try-catch statement is used for both the endpoints. This is a clean way of making sure your errors are handled. The code in the try block is always run first. If any errors happen in this block, the catch block will be triggered. Then, you can focus on how to handle the errors that are caught. This is something that can get overlooked when devs are in a hurry, so it’s a prime candidate to include in your code conventions. 

The validation here is happening through the `UpdateOrderDto`. Here’s what it looks like in `orders.interface.ts`:
```
// orders.interface.ts
…
export class UpdateOrderDto {
  @IsNumber()
  total: number;

  @IsNotEmpty()
  products: Product[];

  @IsNotEmpty()
  userId: number;
}

```

#### Note
**DTO** means **data transfer object**. DTOs are used to encapsulate data commonly used by the service layer on the backend to reduce the amount of data that needs to be sent between the backend and frontend. In a **Model-View-Controller (MVC) framework like NestJS**, these are also useful as the models for application. They mainly define the parameters passed to the methods on the backend.

NestJS handles validation under the hood with the class-validator package, so if the `userId` is empty or the total isn’t a number, an error will be thrown to the frontend telling it the body data was in the wrong format. Sending proper validation messages to the frontend will help the devs know what to do and give users helpful information.

#### Working on the Orders Service
The last file is `orders.service.ts`. This is where the **business logic** for the orders functionality is handled. Refer to the NestJS for more details on service files. Any calculations, sorting, filtering, or other data manipulation is going to happen in this file. Here’s an example of a method to update an order:

```
// orders.service.ts
…
public async updateOrder(params: {
  where: Prisma.OrderWhereUniqueInput;
  data: Prisma.OrderUpdateInput;
}): Promise<Order> {
  const { data, where } = params;
  this.logger.log(`Updated existing order ${where.id}`);

  try {
    const updatedOrder = await this.prisma.order.update({
      data: {
        ...data,
        updatedAt: new Date(),
      },
      where,
    });

    this.logger.log(`Updated for existing order ${updatedOrder.id} successful`);

    return updatedOrder;
  } catch (err) {
    this.logger.log(`Updated for existing order ${where.id} failed`);

    throw new HttpException(err.message, HttpStatus.CONFLICT);
  }
}

```

Now you’re adding even more backend best practices and following the conventions because you have error handling and logging happening here. There will also be errors that come from the service level, which is why you have the try-catch statement to bubble those errors back up to the controller.

You should also add logging like this in your controllers. One thing you’ll find is that logs are invaluable when you’re trying to debug the backend. Make your logs as descriptive as you need to in order to track values across your database and other endpoints or third-party services.

Regardless of the framework you decide to use on the backend, you’ve seen the core things you need to implement: validation on inputs, logging for the crucial parts of the flow, and error handling for issues that may arise. As long as you remember these things and keep the code conventions in mind, your team is on the way to a strongly built codebase.

It’s time to look at some other parts of the backend that will ensure that the endpoints and services work as expected.

#### Checking the Database Connection
Many projects have a folder called `utils` or `helpers` or something similar. You’ll need to create one of those folders to hold the service you’re going to use to instantiate Prisma Client and connect to the database. This was discussed in Chapter 3, so now you’re expanding on that base you already have. In the `src` folder, make a new folder called `utils`. In this folder, create a file called `prisma.service.ts` and put this code from the NestJS documentation in the file.

You don’t have to worry about writing everything from scratch most of the time if you spend a few minutes reading and looking through docs. That’s a thing you’ll find senior devs doing all the time. Also, don’t be afraid to add more things to this utils folder! When you see small functions that are repeated in numerous parts of the app, like data formatters, move them here so that they are easy for other devs to find and use.

If you haven’t stopped to make a Git commit, this is a good time to do so. Now you have the backend in a state where other devs can come in and add more functionality or configurations. One of the hardest tasks is to set something up that others can improve. That’s what you’re doing right now.

As you build on this application throughout the book, you’ll start to add calls to third-party services, handle data from different sources, and work on security concerns. All of these will involve endpoints and other service methods that you’ll add on as you move through the tasks on your sprint.

It’s important to get some practice in, so try to add error handling, logging, and validation to the remaining endpoints in the orders controller. Of course, you can always check out the GitHub repo, too.

## Conclusion
We covered a lot in this chapter, and we will dive even deeper in Chapters 5 through 10! The main takeaways from this chapter are making an agreement with the engineers working on the frontend, setting up strict conventions for your API as soon as possible, creating some initial endpoints to get the frontend devs moving, and error handling, validation, and logging. Now that you have a few endpoints up, you can start building on top of them.


## Chapter 5. Third-Party Services
There will come a point in developing a product when you’ll need to use a third-party service. Third-party services offer complex or proprietary functionality that exists outside your codebase and your company. The third-party service is usually managed by another company; you pay a fee to use it and have access to support when things go wrong.

Third-party services come up when you need functionality that would take a significant amount of time to implement, would be difficult to maintain, and would likely need its own team, such as payment systems, authentication/authorization, and monitoring and logging for your app.

In this chapter, I’ll go over:

- Choosing third-party services

- Implementing a third-party service in your system

- Managing errors, outages, and upgrades

Working with third-party services is going to come up at some point, so it’s best to go in with an idea of what you’re getting into. Usually, the third-party service provides an API or software development kit (SDK) as an npm package that you install in your app, but you’ll need to provide some type of credentials to access the full functionality. There are also some SDKs that exist without a service just to give you specific functionality.

Keep in mind that there’s a chance that something on the service’s side could change and break without letting you know. It’s all interface code that you’ll be working with, so it won’t be any different in that regard.

We’ll be adding Stripe as the third-party service to handle the payment part of the app. First, I’ll go over some things you should consider for third-party services. Then, you’ll implement the controller, service, and other code to get Stripe working in the demo project.

#### Choosing a Third-Party Service
There are numerous services to handle payments, authentication, data processing, tax handling, logging, working with other company’s data, and any other functionality you can think of. That can make the task of choosing a service seem daunting because you have to decide what to build and balance that with costs. In reality, this is pretty similar to the process of selecting a package to use in your code.

The most important difference between selecting a third-party service and a package is that the services cost money. There’s nothing wrong with selecting a paid service over a free package if it’s going to save you development time and get features out faster and with more confidence that the app will work as expected. Getting locked into a great product with a good pricing structure is something to hope for compared to the opposite.

Here are some things you might look into as you research services you need:

- Does it have good documentation that is regularly updated?

- How are new version releases handled?

- Is responsive support available?

- Is the pricing structure clearly defined, even if you have to get on a call with a sales rep?

- Are there other options for the functionality you need?

- Is the company mature and stable?

- How easy would it be to add the solution to your existing architecture?

- How does this solution compare to other popular solutions for this service?

- Is there a good sandbox environment for testing?

- How much effort would it take to switch to a different tool from this one?

These are all things to consider, and there will be some interesting trade-offs. You might even get into more industry-specific questions around legal compliance and regulations. Once you’ve done a thorough business analysis of a service, take it for a spin in your codebase. See how long it takes to add the smallest working integration to your code. That’ll be a good early test run to see what it would be like working with the service.

When you’re doing this testing, don’t forget to share your findings with the team as well as with management. Do some quick demos to show how things are going in the code. This is one way you can help others on the team level up. It’ll also help you understand the service at a deeper level because you’ll be answering questions that the team has.

While you’re checking out how the integration works, look into the reputation of the product and company. It’s important to know the experiences other developers have had with any service you’re considering paying for. If the service seems awesome and has great support, see if anyone else had that experience after they signed a contract. It may seem cynical, but it’s good to check these things out before you are deeply integrated with a product.

You also need to consider the country of origin of the service. If you develop software for any government, there will likely be countries that you have to avoid selecting software from. This is something you might not initially think about depending on what industry you’re in, but geopolitics affects the tools we use to develop software. On the other side, if your company wants to show its support for a country, you can evaluate services for good geopolitical reasons.

As you continue to research third-party services, consider looking at the GitHub repo for the service if there is one. You’ll be able to see other developers’ experiences with it and how the third-party service company handled any bugs or questions. You’ll probably find the most common issues everyone runs into before you’re too deep into the implementation.

One more thing to check for is how third-party services interact with one another. You may need to use multiple services through another service like Zapier or your cloud provider’s services, which can complicate things. See if any of the services complement the other tools and services you’re using.

List of Potential Services
It can be hard to know what to even look at when you figure out you need a third-party service. These are some options to start with:

#### Payment handlers
- Stripe

- Square

- Clover

- PayPal

- Paddle

#### Logging/monitoring
- DataDog

- New Relic

- Splunk

- Sentry

#### Third-party apps
- Meta

- Instagram

- YouTube

- Google Workspace

#### Ecommerce
- Shopify

- Amazon

- Etsy

- BigCommerce

#### Authentication
- Auth0

- FusionAuth

- Amazon Cognito

- SuperTokens

- Clerk

#### Email services
- SendGrid

- Amazon Simple Email Service (SES)

- Mailgun

- Postmark

- Brevo

#### Geolocation
- Google Maps

- Mapbox

- Esri ArcGIS

- Radar

You may run into some very niche services out there depending on what your product needs. These services can be challenging to integrate, so make sure you are clearly communicating what you’re finding and ask others to join in the search, too.

Always check the data structure that you’ll get from the API responses because some of them won’t be as well documented as others. Do some initial exploration between services you’re considering to see what you will get back. This is another good way to evaluate how well a service is going to fit into your infrastructure. You’d be surprised at the response structure you’ll get back from some of the services you’ll use over the years.

Since the app you’re building will require the ability for users to make payments, you’ll need to implement a third-party service to handle this: a service that has Payment Card Industry Data Security Standard (PCI DSS) compliance built in and has lots of security in place to keep users’ financial and personal information secure. For this part of the project, you’ll get to work with Stripe.

#### Integrating Stripe
The reason you’ll use Stripe in this project is because it has great documentation (which you’ll refer to often), a large community of developers uses it, and there’s a pretty good testing environment for it. I still encourage you to take a look at some of the other options and compare the trade-offs you see.

#### Note
I won’t go through setting up a Stripe account because it gets pretty in-depth, and you will need to add your personal information. If you don’t feel comfortable doing that, it’s OK. This information will be provided by your organization anyway. I’ll go over the programmatic implementation so that you can follow along with the code to see what you would do after the account is set up.

The first thing you need to do is decide how you want to handle third-party services in your app. When you’re thinking about this, keep in mind that you will likely have other integrations as the product grows and needs more capabilities. The approach you’ll take in this project is adding a new folder called integrations in src. Inside the integrations folder, you’ll add a subfolder called stripe with a few files in it. This will make your folder tree look like this:

```
|__ prisma
|__ src
|____ integrations
|______ stripe
|________ stripe.controller.spec.ts
|________ stripe.controller.ts
|________ stripe.interface.ts
|________ stripe.module.ts
|________ stripe.service.spec.ts
|________ stripe.service.ts
|____ orders
|____ app.module.ts
|____ main.ts
|__ test

```

This is also a great time to update your architecture diagram to show how this new service integrates with your overall app, as in Figure 5-1. Docs are never really finished, so remember to update relevant docs as you add new functionality. The way third-party services will work with this app includes some event handling with your cloud service using tools like Amazon CloudWatch and EventBridge as well as directly interfacing with your own APIs.

<img width="600" height="608" alt="image" src="https://github.com/user-attachments/assets/b35df6e2-9b4d-4167-b670-16611d719468" />

You’ll follow the same programming pattern here as you did with the orders functionality. The endpoints your frontend will call are defined in the controller. The interactions directly with the Stripe API will be in the service. Keeping this separation of concerns is what helps make your code modular and easier to test. You’ll want to keep that up even as you add other third-party code.

You can start by updating the new stripe.module.ts file to import and use the new service and controller because this is a quick win:
```
// stripe.module.ts
import { Module } from '@nestjs/common';
import { StripeService } from './stripe.service';
import { StripeController } from './stripe.controller';

@Module({
  exports: [StripeService],
  providers: [StripeService],
  controllers: [StripeController],
})
export class StripeModule {}
```


#### Note
Starting with a quick win is a way to build up momentum when you’re facing something big. It can make the problem feel more approachable. As you write out functionality, see if you like to write code in a specific order. It can help you get to the more complex details faster. Throughout this book, I’ll typically start with the initial module imports, move on to the controller, and finish with the service. I’ll update the interface as we go and save the tests for last. But I tend to jump around files a lot during real development.

You need to add a new environment variable to .env to use the Stripe API. You’ll get this value from your account, but there’s a test one you can use that’s found in the docs. So in your .env, add the following line.

```
STRIPE_SECRET_KEY="sk_your_stripe_account_secret_key"

```

#### Writing the Controller
From here, you can jump into your Stripe controller and start writing out endpoints you’ll use. You’ll need an endpoint to take user payments and an endpoint to update your products in Stripe’s system. Open stripe.controller.ts and add this code to start making the endpoints:

```
// stripe.controller.ts
import {
Body,
Controller,
Headers,
HttpException,
HttpStatus,
Post,
Res
} from '@nestjs/common';
import { StripeService } from './stripe.service';
import { CreateStripePaymentDto } from './stripe.interface';

@Controller('/v1/stripe')
export class StripeController {
  constructor(private readonly stripeService: StripeService) {}

  @Post('/payments')
  public async createPayment(
    @Body() payment: CreateStripePaymentDto,
    @Headers() headers,
    @Res() res,
  ) {
    try {
      const paymentInfo = await this.stripeService.createPayment({
        payment,
        res,
        origin: headers.origin,
      });

      return paymentInfo;
    } catch (err) {
      throw new HttpException('Something happened', HttpStatus.NOT_FOUND);
    }
  }
}


```

In this controller, you’ve defined one endpoint. The endpoint is how you can handle payments through Stripe. This one is a little different; you’ll need to do a redirect in your service method because the user will be sent to Stripe’s checkout page through the payment request, and you need a way to send them back to your app after the payment has been made. You can check out why you do the redirect by looking at the diagram on how Stripe handles checkouts.

Keep in mind you have the CreateStripePaymentDto in this controller, so you need to double-check that the interface meets the exact data requirements. As the app grows, you will also have some nested validation so that you can ensure you’re sending the correct values to Stripe’s API:

```
// stripe.interface.ts
import { IsNotEmpty, MinLength } from 'class-validator';

export class CreateStripePaymentDto {
  @IsNotEmpty()
  priceId: string;

  @MinLength(1, {
    message: 'quantity has to be at least 1',
  })
  quantity: number;
}
```


This validation functionality can be done with other packages like Joi or Zod in your middleware if you aren’t using NestJS. StripePriceData is something you may use multiple times throughout your service implementation as it grows. A good practice is to mirror the types and requirements from the service docs so that you know you’re sending exactly what they expect. Sometimes you can simply use the types that come directly from the SDK.

There are also times when you know that you’ll be using only certain fields from the types and you’ll be adding other fields that don’t come from the SDK. You’ll have to determine if it’s worth the time to fit the SDK types into what you need or if you should write your own. When you know that you’ll use the response exactly how it comes to you, go ahead and use the SDK types. If you know that you will have some new combination of fields or the SDK types need to be in a different format, consider mirroring the types to build your own interface.

#### Note
Not every service is as developer friendly as Stripe. If you aren’t sure what types the request expects or what the response will be, just test the service and see what you get back. Sometimes, third-party services require a discovery phase so that you know what you’re working with and how you can add the correct types to your app. You might use tools like mitmproxy or even Postman to see what you’ll be working with.

Writing the Service
Now that you’ve written out the bulk of the code for the controller, turn your attention to the service where you’ll work directly with Stripe. Stripe has a nice npm package that will let you use the API.

Let’s implement the ability to make payments in Stripe. As you write the code, you can reference the docs for the checkout API to handle payments. In stripe.service.ts, you’ll do some file setup like importing packages and adding your constructor and logger. Then you can add the method to handle the request to the Stripe checkout API for your payments:
```
// stripe.service.ts
…

@Injectable()
export class StripeService {
  private readonly logger = new Logger(StripeService.name);
  // Keep the version string like this because Stripe said so
  private stripe =
    new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: '2023-08-16' });

  public async createPayment({
    payment,
    origin,
    res,
  }: {
    payment: CreateStripePaymentDto;
    origin: string;
    res: any;
  }) {
    this.logger.log('Started payment in Stripe');

    try {
      // Create Checkout Sessions from body params.
      const session = await this.stripe.checkout.sessions.create({
        line_items: [
          {
            // Provide the Price ID (for example, price_H5ggYwtDq4fbrJ) of the
            // product you want to sell
            price: payment.priceId,
            quantity: payment.quantity,
          },
        ],
        mode: 'payment',
        success_url: `${origin}/?success=true`,
        cancel_url: `${origin}/?canceled=true`,
      });

      res.status(303).redirect(session.url);
    } catch (err) {
      throw Error('Something happened with Stripe');
    }
  }
}
```

One of the biggest things to note here is the logger that’s been initialized in the service. The logs you write will be invaluable when you’re debugging issues because you can create a record of every action that happens. When you combine this with another third-party service like Datadog, the insights you get will help you fix issues with precision.

Between the logs and the error handling is the heart of third-party service integration: making sure that your code can handle any issues that come up from the third-party code. One thing to note is that third-party code might break some of your conventions, but that’s one of the trade-offs of using the service.

Something else to keep in the back of your mind are any edge cases you can think of. What will your app do if the service you need is down? It’s important to have this conversation with the Product team as you find out the quirks of the service through all your testing, which you’ll get into in Chapter 7.

You’ll see there’s a new field that needs to be added to the database: s⁠t⁠r⁠i⁠p⁠e⁠P⁠r⁠o⁠d⁠u⁠c⁠t​I⁠d. You want to keep track of some third-party data in your system so that you can perform actions through the API and validate any changes. That means you’ll need to update the schema.prisma and run a migration. I’ll leave that to you to do, but you can check your schema.prisma against the version in the GitHub repo.

Conclusion
This chapter focused on getting comfortable researching and using third-party services in your code. The most important thing to remember when working with these services is that sometimes they just don’t behave the way you expect. Weird race conditions can happen, data can come back in inconsistent formats, and request parameters can change. This is where error handling and logging will be your best friends. Issues will pop up with third-party services from time to time, and that’s OK. It’s nothing you can’t handle with some communication among the dev and Product teams and a willingness to try different code strategies.








