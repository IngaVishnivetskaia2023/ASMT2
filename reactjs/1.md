## Understanding React Components and JSX

### What Are Components?
A key concept of React is the usage of so-called components. Components are reusable building blocks that are combined to compose the final user interface. 
For example, a basic website could be made up of a sidebar that includes navigation items and a main section that includes elements for adding and viewing tasks.

### Why Components?
No matter which web page you look at, they are all made up of building blocks like this. 
**It‚Äôs not a React-specific concept or idea.** Indeed, HTML itself ‚Äúthinks‚Äù in components if you take a closer look. 
You have elements like `<img>`, `<header>`, `<nav>`, etc., and you combine these elements to describe and structure your website content.

But React embraces this idea of breaking a web page into reusable building blocks because it is an approach that allows developers to work on small, manageable chunks of code. 
It‚Äôs easier and more maintainable than working on a single, huge HTML (or React code) file.

That‚Äôs why other libraries‚Äîboth frontend libraries like `React` or `Angular` as well as backend libraries and templating engines like `EJS` (Embedded JavaScript templates)‚Äîalso embrace components 
(though the names might differ, you also find ‚Äúpartials‚Äù or ‚Äúincludes‚Äù as common names).

### What Exactly Are Component Functions?
In React, **components are functions** (or classes, but as mentioned above, those aren‚Äôt relevant anymore).

A function is **a regular JavaScript construct, not a React-specific concept**. This is important to note. 
**React is a JavaScript library** and consequently uses JavaScript features (like functions); React is not a brand-new programming language.

When working with React, regular JavaScript functions can be used to encapsulate HTML (or, to be more precise, JSX) code and JavaScript logic that belongs to that markup code. 
However, it depends on the code you write in a function whether it qualifies to be treated as a React component or not. 
For example, in the code snippets above, the `handleSubmit` function is also a regular JavaScript function, but it‚Äôs not a React component. 
The following example shows another regular JavaScript function that doesn‚Äôt qualify as a React component:

```
function calculate(a, b) {
  return {sum: a + b};
};
```

Indeed, **a function will be treated as a component and can therefore be used like an HTML element in JSX code if it returns a renderable value (typically JSX code)**. 
This is very important. 
‚ùó You can only use a function as a React component in JSX code if it is a function that returns something that can be rendered by React. 
The returned value technically doesn‚Äôt have to be JSX code, but in most cases, it will be. 
You will see an example of non-JSX code being returned in Chapter 7, Portals and Refs.

When working with vanilla JavaScript, you, of course, typically call functions to execute them. With functional components, that‚Äôs different. 
**React calls these functions on your behalf**, and for that reason, as a developer, you use them like HTML elements inside of this JSX code.

When using React, you don‚Äôt create brand-new HTML elements that the browser would be able to display and handle. 
Instead, **you create components that only work inside the React environment**. 
Before they reach the browser, they **have been evaluated by React and ‚Äútranslated‚Äù into DOM-manipulating JavaScript instructions** (like `document.append(‚Ä¶)`).

But keep in mind that all this JSX code is a feature that‚Äôs not part of the JavaScript language itself. 
It‚Äôs basically syntactical sugar (i.e., a simplification regarding the code syntax) provided by the React library and the project setup you‚Äôre using to write React code. 
Therefore, elements like `<div>`, **when used in JSX code**, also **aren‚Äôt normal HTML elements** because **you don‚Äôt write HTML code**. 
It might look like that, but it‚Äôs inside a `.jsx` file and **it‚Äôs not HTML markup**. Instead, it‚Äôs this **special JSX code**. It is important to keep this in mind.

Accordingly, these `<div>` and `<h2>` elements you see in all these examples are also **just React components in the end**. But they are not components built by you, but instead provided by React (or, to be precise, by ReactDOM).

When working with React, you consequently always end up with these primitives‚Äîthese built-in component functions that are later translated to browser instructions that generate and append or remove normal DOM elements. **The idea behind building custom components is to group these elements together such that you end up with reusable building blocks** that can be used to build the overall UI. 
But, in the end, this UI is made up of regular HTML elements.

üììNote ‚ùó Depending on your level of frontend web development knowledge, you might have heard about a web feature called **Web Components**. 
The idea behind this feature is that you can indeed build brand-new HTML elements with vanilla JavaScript. As mentioned, React **does not pick up this feature**; 
you don‚Äôt build new custom HTML elements with React.


### JSX vs HTML vs Vanilla JavaScript
As mentioned above, React projects typically contain lots of JSX code. Most custom components will return JSX code snippets. You can see this in all the examples shared thus far, and you will see it in basically every React project you explore, no matter whether you are using React for the browser or other platforms like react-native.

But what exactly is this JSX code? How is it different from HTML? And how is it related to vanilla JavaScript?

‚ùó JSX is a feature that‚Äôs not part of vanilla JavaScript. What can be confusing, though, is that **it‚Äôs also not directly part of the React library**.

Instead, **JSX is syntactical sugar that is provided by the build workflow that‚Äôs part of the overall React project**. 
When you start the development web server via `npm run dev` or build the React app for production (i.e., for deployment) via `npm run build`, you kick off a process that transforms this JSX code back to regular JavaScript instructions. As a developer, you don‚Äôt see those final instructions but React, the library, actually receives and evaluates them.

So, what does the JSX code get transformed to?

In modern React projects, it gets transformed to rather complex, unintuitive code that looks something like this:
```
function Ld() {
  return St.jsx('p', { children: 'Welcome to this book!' });
}
```

Of course, this code is not very developer-friendly. It‚Äôs not the kind of code you would write. 
Instead, it‚Äôs the code produced by Vite (i.e., by the underlying build process) for the browser to execute.

But you could, in theory, write code like this instead of using JSX‚Äîif, for some reason, you wanted to avoid writing JSX code. 
React has a built-in method you can use instead of JSX: you can use React‚Äôs `createElement(‚Ä¶)` method.

Here‚Äôs a concrete example, first in JSX:
```
function Greeting() {
  return <p>Hello World!</p>;
};
```

Instead of using JSX, you could also write this component code like this:
```
function Greeting() {
  return React.createElement('p', {}, 'Hello World!');
};
```

`createElement()` is a method built into the React library. 
It instructs React to create a paragraph element with `Hello World!` as child content (i.e., as inner, nested content). 
This paragraph element is then created internally first (via a concept called the `virtual DOM`, which will be discussed later in the book, in Chapter 10, Behind the Scenes of React and Optimization Opportunities). Thereafter, once all elements for all JSX elements have been created, **the virtual DOM is translated into real DOM-manipulating instructions** that are executed by the browser.

#### JSX Elements Are Treated Like Regular JavaScript Values
Because JSX is just syntactical sugar that gets transformed, there are a couple of noteworthy concepts and rules you should be aware of:

- JSX elements are just regular JavaScript values (functions, to be precise) in the end
- The same rules that apply to all JavaScript values also apply to JSX elements
- As a result, in a place where only one value is expected (e.g., after the return keyword), you must only have one JSX element

This code would cause an error:
```
function App() {
  return (
    <p>Hello World!</p>
    <p>Let's learn React!</p>
  );
};
```

The code might look valid at first, but it‚Äôs actually incorrect. In this example, you would return two values instead of just one. That is not allowed in JavaScript.

For example, the following non-React code would also be invalid:
```
function calculate(a, b) {
  return (
    a + b
    a - b
  );
};
```

You can‚Äôt return more than one value. No matter how you write it.

Of course, you can return an array or an object though. For example, this code would be valid:
```
function calculate(a, b) {
  return [
    a + b,
    a - b
  ];
};
```

It would be valid because you only return one value: an array. This array contains multiple values, as arrays typically do. That would be fine and the same would be the case if you used JSX code:
```
function App() {
  return [
    <p>Hello World!</p>,
    <p>Let's learn React!</p>
  ];
};
```

This kind of code would be allowed since you are returning one array with two elements inside of it. The two elements are JSX elements in this case, but as mentioned earlier, JSX elements are just regular JavaScript values. Thus, you can use them anywhere where values would be expected.

When working with JSX, you won‚Äôt see this array approach too often though‚Äîsimply because it can become annoying to remember wrapping JSX elements via square brackets. It also looks less like HTML, which kind of defeats the purpose and core idea behind JSX (it was invented to allow developers to write HTML code inside JavaScript files).

Instead, if sibling elements are required, as in these examples, a special kind of wrapping component is used: a React `fragment`. That‚Äôs a built-in component that serves the purpose of allowing you to return or define sibling JSX elements:
```
function App() {
  return (
    <>
      <p>Hello World!</p>
      <p>Let's learn React!</p>
    </>
  );
};
```

The parentheses `(())` that are wrapped around the JSX code in all these examples are required to allow for nice **multiline formatting**. 
Technically, you could put all your JSX code into one single line, but that would be pretty unreadable. 
In order to split the JSX elements across multiple lines, just as you typically do with regular HTML code in `.html` files, you need those parentheses; 
they tell JavaScript where the returned value starts and ends.

Since JSX elements are regular JavaScript values (after being translated by the build process at least), you can also use JSX elements in all the places where values can be used.

Thus far, that has been the case for all these return statements, but you can also store JSX elements in variables or pass them as arguments to other functions:
```
function App() {
  const content = <p>Stored in a variable!</p>; // this works!
  return content;
};
```


#### Outputting Dynamic Content
At this point in the book, you don‚Äôt yet have any tools to make the content more dynamic. To be precise, React requires that state concept (which will be covered in Chapter 4, Working with Events and State) to change the content that is displayed (e.g., upon user input or some other event).

Nonetheless, since this chapter is about JSX, it is worth diving into the syntax for outputting dynamic content, even though it‚Äôs not yet truly dynamic:
```
function App() {
  const userName = 'Max';
  return <p>Hi, my name is {userName}!</p>;
};
```

This example technically still produces static output since userName never changes, but you can already see the syntax for outputting dynamic content as part of the JSX code. 
You use opening and closing curly braces `({‚Ä¶})` with a JavaScript expression (like the name of a variable or constant, as is the case here) between those braces.

You can put **any valid JavaScript expression** between those curly braces. 
For example, you can also call a function (e.g., `{getMyName()}`) or do simple inline calculations (e.g., `{1 + 1}`).

You **can‚Äôt add complex statement**s like loops or `if` statements between those curly braces though. 
Again, standard JavaScript rules apply. You output a (potentially) dynamic value, and therefore, anything that produces a single value is allowed in that place. 
However, it‚Äôs worth noting that a few value types can‚Äôt be used for outputting a value in JSX. For example, **trying to output a JavaScript object in JSX will cause an error**.

It‚Äôs also worth noting that you‚Äôre not limited to outputting dynamic content between element tags. Instead, you can also set dynamic values for attributes:
```
function App() {
  const userName = 'Max';
  return <input type="text" value={userName} />;
};
```

#### Rendering Images
Most websites do not just display plain text. Instead, you often need to render images as well.

Of course, when working with React, you can use the default `<img />` element like in any other web project. 
But there are two important things to keep in mind when displaying images in React projects:

- `<img />` must be a self-closing tag.
- When displaying local images stored inside of the `src/` folder, you must import them into your `.jsx` files.

As explained above, in the **JSX elements must have a closing tag** section, you can‚Äôt have void JSX elements, i.e., elements without any closing tag.

In addition, when outputting **locally** stored images (i.e., images stored in the project‚Äôs `src/` folder, not on some remote server), you typically don‚Äôt set a string path to the image in your code.

You might be used to outputting images like this:
```
<img src="assets/images/wave.jpg">
```

But React projects (e.g., when created with Vite) do involve some kind of build process. In most projects, **the final project structure that will be deployed onto a server will look quite different from the project structure you work on during development**.

That being the case, if you store an image in the `src/assets` folder in a Vite-based React project, and you use that as a path (`<img src="src/assets/my-image.jpg" />`), the image **will not load** on the deployed website. ‚ùó It will not load there because the deployable folder structure will not contain a `src/assets` folder anymore.

Indeed, you can get an idea of the production-ready folder structure by running `npm run build`. This will build the project for deployment and produce a new `dist` folder in your project directory. It‚Äôs the content of that `dist` folder that will be deployed onto some server. If you inspect that folder, you won‚Äôt find a `src` folder in there.

<img width="262" height="206" alt="image" src="https://github.com/user-attachments/assets/eea77ae5-117f-4d86-9ab6-008a913667ba" />


Put in other words: You can‚Äôt tell the exact path of a locally stored image in advance. That‚Äôs why you **should import the image file** into your `.jsx` file. 
As a result, you‚Äôll get a string value that will contain the actual path (which will work in production). This value can then be set as a dynamic value for the src attribute of the `<img />` element:
```
import myImage from './assets/my-image.png';
function App() {
  return <img src={myImage} />;
};
```

This might look strange at first, but it is code that will work in pretty much all React projects. 
Behind the scenes, this import gets analyzed by the underlying build process. 
The import statement then gets removed, and the image path is hardcoded into the production-ready output code (i.e., the code that‚Äôs stored in the `dist` folder).

There is one important exception though: if you store an image file (or, actually, any asset) in the `public/` folder of your project, you can directly reference its path.

For example, a `demo.jpg` image file stored in `public/images/demo.jpg` can be rendered and displayed like this:
```
function App() {
  return <img src="/images/demo.jpg" />;
};
```

This works because the contents of the `public/` folder are simply copied into the `dist/` folder. 
Unlike the `src/` folder and its nested files, the `public/` folder files skip the transpilation step.

Please note that the public folder name itself is not part of the paths referenced‚Äîit‚Äôs `src="/images/demo.jpg"`, not `src="/public/images/demo.jpg"`.

#### Which approach should you use then? Store images in `src/` or `public/`?

For most images, `src/` is a sensible choice since the pre-processing step assigns a unique file name to each imported file. 
As a result, files can be cached more efficiently once the application is deployed.

Any files imported in the root `index.html` file, or files where the file name must never change (e.g., because it‚Äôs also referenced by some other app, running on some other server) should typically go into the `public/` folder.

Thus, in most cases, when outputting images that are stored locally in your project, you should store them in the `src/` folder and then import them into your JSX files. When using images that are stored on some remote server, you would instead use the full image URL:
```
function App() {
  return <img src="https://some-server.com/my-image.jpg" />;
};
```

#### When Should You Split Components?
As you work with React and learn more and more about it, and as you dive into more challenging React projects, you will most likely come up with one very common question: When should I split a single React component into multiple separate components?

As mentioned earlier in this chapter, React is all about components, and it is therefore very common to have dozens, hundreds, or even thousands of React components in a single React project.

When it comes to splitting a single React component into multiple smaller components, there is no hard rule you must follow. As mentioned earlier, you could put all your UI code into one single, large component. Alternatively, you could create a separate custom component for every single HTML element and piece of content that you have in your UI. Both approaches are probably not that great. Instead, a good rule of thumb is to create **a separate React component for every data entity** that can be identified.

For example, if you‚Äôre outputting a ‚Äúto-do‚Äù list, you could identify two main entities: the individual to-do item and the overall list. In this case, it could make sense to create two separate components instead of writing one bigger component.

The advantage of splitting your code into multiple components is that the individual components stay manageable because there‚Äôs less code per component and component file.

However, when it comes to splitting components into multiple components, a new problem arises: How do you make your components reusable and configurable?
```
import Todo from './todo.jsx';
function TodoList() {
  return (
    <ul>
      <Todo />
      <Todo />
    </ul>
  );
};
```

In this example, all ‚Äúto-dos‚Äù would be the same because we use the same `<Todo />` component, which can‚Äôt be configured. You might want to make it configurable by either adding custom attributes (`<Todo text="Learn React!" />`) or by passing content between the opening and closing tags (`<Todo>Learn React!</Todo>`).

And, of course, React supports this. In the next chapter, you will learn about a key concept called props, which allows you to make your components configurable like this.
