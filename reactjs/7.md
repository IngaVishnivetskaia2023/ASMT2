## Understanding React Suspense & The use() Hook

#### Learning Objectives

By the end of this chapter, you will be able to do the following:

- Describe the purpose and functionality of React’s Suspense feature
- Use Suspense with RSCs to show fallback content on a granular level
- Use Suspense for client components via React’s use() Hook
- Apply different Suspense strategies for data fetching and fallback content


### Introduction
In Chapter 10, Behind the Scenes of React and Optimization Opportunities, in the Reducing Bundle Sizes via Code Splitting (Lazy Loading) section, you learned about React’s `<Suspense>` component and how it may be used in the context of lazy loading and code splitting to show fallback content while a code bundle is being downloaded.

As explained there, the purpose of the Suspense component is to simplify the process of showing fallback content, which, in turn, can lead to a better user experience. Since staring at outdated content or a blank page is not something most users appreciate, having a built-in feature that shows alternative content is very convenient.

In this chapter, you’ll learn that React’s Suspense component is not limited to being used for code splitting. 
Instead, it can also be used for data fetching to show some temporary content while data is being loaded (e.g., from a database). 
Though, as you will also learn, Suspense can only be used for data fetching if the data is fetched in a certain way.

In addition, this chapter will revisit the `use()` Hook, which was introduced in Chapter 11, Working with Complex State. 
As you will learn, besides using it for getting access to context values, this Hook can be used in conjunction with `Suspense` as well.

### Showing Granular Fallback Content with Suspense
When fetching data or downloading a resource (e.g., a code file), loading delays can occur—delays that can lead to a bad user experience. 
You should therefore consider showing some temporary fallback content while waiting for the requested resource.

For that reason, to simplify the process of rendering fallback content while waiting for some resource, React offers its Suspense component. 
As shown in Chapter 10, Behind the Scenes of React and Optimization Opportunities, you can use the Suspense component as a wrapper around React elements that fetch some code or data. 
For example, when using it in the context of code splitting, you can show some temporary fallback content like this:

```
import { lazy, Suspense, useState } from 'react';
const DateCalculator = lazy(() => import(
    './components/DateCalculator.jsx'
  )
);
function App() {
  const [showDateCalc, setShowDateCalc] = useState(false);
  function handleOpenDateCalc() {
    setShowDateCalc(true);
  }
  return (
    <>
      <p>This app might be doing all kinds of things.</p>
      <p>
        But you can also open a calculator which calculates 
        the difference between two dates.
      </p>
      <button onClick={handleOpenDateCalc}>Open Calculator</button>
      <Suspense fallback={<p>Loading...</p>}>
        {showDateCalc && <DateCalculator />}
      </Suspense>
    </>
  );
}
```

In this example (which is from a regular Vite-based React project), React’s `Suspense` component is wrapped around the conditionally rendered `DateCalculator` component. 
`DateCalculator` is created with the help of React’s `lazy()` function, **which is used to lazily (i.e., on demand) load the code bundle** that belongs to this component.

As a result, the entire other page content is shown right from the start. 
Only the conditionally displayed `DateCalculator` component is replaced with the fallback content (`<p>Loading...</p>`) while the code is being fetched. 
Thus, `Suspense` is used to render some fallback JSX code **on a very granular level**. 
Instead of replacing the entire page or component markup with some temporary content, only a small part of the UI is replaced.

Of course, `Suspense` therefore provides a functionality that would also be nice to have when fetching data—after all, delays occur frequently there, too.

### Using Suspense for Data Fetching with Next.js
As explained in the previous chapter, in the Managing Loading States with Next.js section, the process of data fetching also often comes with waiting times that can negatively impact user experience. 
That’s why, in that same section, you learned that Next.js allows you to define a `loading.js` file that contains some fallback component that’s rendered during such a delay.

However, using that approach **essentially replaces the entire page (or the main area of that page)** with the loading fallback component content. 
But that’s not always ideal—you instead might want to display some loading fallback content on a more granular level when fetching data.

Thankfully, in Next.js projects, you can use `Suspense` in a similar way, as shown in the example from the previous section, to wrap it around components that fetch data. 
Since Next.js supports HTTP response streaming, it’s able to render the rest of the page immediately while streaming the content that depends on the fetched data to the client side once it’s available. 
Until the data is loaded and available, `Suspense` will render its defined fallback.

Therefore, coming back to the example from the Managing Loading States with Next.js section of Chapter 16, React Server Components & Server Actions, you can take advantage of `Suspense` by outsourcing the data fetching code into a separate UserGoals component:

```
import fs from 'node:fs/promises';
async function fetchGoals() {
  await new Promise((resolve) => setTimeout(resolve, 3000)); // delay
  const goals = await fs.readFile('./data/user-goals.json', 'utf-8');
  return JSON.parse(goals);
}
export default async function UserGoals() {
  const fetchedGoals = await fetchGoals();
  return (
    <ul>
      {fetchedGoals.map((goal) => (
        <li key={goal}>{goal}</li>
      ))}
    </ul>
  );
}
```

This `UserGoals` component can then be wrapped with `Suspense` in the `GoalsPage` component like this:
```
import { Suspense } from 'react';
import UserGoals from '../../components/UserGoals';
export default async function GoalsPage() {
  return (
    <>
      <h1>Top User Goals</h1>
      <Suspense fallback={
        <p id="fallback">Fetching user goals...</p>}
      >
        <UserGoals />
      </Suspense>
    </>
  );
}

```

This code now utilizes React’s Suspense component to show a fallback paragraph while the UserGoals component is fetching data.

#### Note

You can find the complete demo project code on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense.

As a result, when users navigate to `/goals`, they immediately see the title (the `<h1>` element) in combination with the fallback content. There is no need for a separate `loading.js` file anymore.

<img width="877" height="195" alt="image" src="https://github.com/user-attachments/assets/0d102779-be65-4489-8783-e176e25407e0" />

Figure 17.1: The fallback content is shown as part of the target page, instead of entirely replacing it

However, the advantage of using Suspense in this situation is not just that the loading.js file isn’t needed anymore. Instead, data fetching and fallback content can now be managed on a very granular level.

For example, in a more complex online shop application, you could have a component like this:

```
function ShopOverviewPage() {
  return (
    <>
      <header>
        <h1>Find your next deal!</h1>
        <MainNavigation />
      </header>
      <main>
        <Suspense fallback={<DailyDealSkeleton />}>
          <DailyDeal />
        </Suspense>
        <section id="search">
          <h2>Looking for something specific?</h2>
          <Search />
        </section>
        <Suspense fallback={<p>Fetching products...</p>}>
          <Products />
        </Suspense>
      </main>
    </>
  );
}
```

In this example, the <header> and <section id="search"> elements are always visible and rendered. 
On the other hand, <DailyDeal /> and <Products /> are only rendered once their data has been fetched. Until then, their respective fallbacks are displayed.

<img width="877" height="520" alt="image" src="https://github.com/user-attachments/assets/80d5030d-d583-4aaa-a38c-6df842288213" />

Figure 17.2: Placeholders are shown initially until loaded data is streamed in and rendered to the screen

`<DailyDeal />` and `<Products />` will be loaded and rendered independently from each other since they’re wrapped by two different `Suspense` blocks. 
Consequently, users will immediately see the header and search area, and then eventually see the daily deal and products—though either of the two may load and render first.

What’s important about these examples is that the components wrapped by Suspense are RSCs that use `async/await`. 
As you will learn in the next section, **not all React components will interact with the Suspense component**. But React Server Components, in Next.js projects, will.

### Using Suspense in Other React Projects—Possible, But Tricky
The previous section explored how you may take advantage of Suspense for data fetching with RSCs in Next.js projects.

However, Suspense is not a Next.js-specific feature or concept—instead, it’s provided by React itself. Consequently, you can use it in any React project to show fallback content while data is being fetched.

At least, that’s the theory. But as it turns out, you can’t use it with all components and data fetching strategies.

### Suspense Does Not Work with useEffect()
Since fetching data via `useEffect()` is a common strategy, you might be inclined to use Suspense in conjunction with this Hook to show some fallback content while data is being loaded via the effect function.

For example, the following BlogPosts components uses `useEffect()` to load and display some blog posts:

```
import { useEffect, useState } from 'react';
function BlogPosts() {
  const [posts, setPosts] = useState([]);
  useEffect(() => {
    async function fetchBlogPosts() {
      // simulate slow network
      await new Promise((resolve) => setTimeout(resolve, 3000));
      const response = await fetch(
        'https://jsonplaceholder.typicode.com/posts'
      );
      const posts = await response.json();
      setPosts(posts);
    }
    fetchBlogPosts();
  }, []);
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

You could wrap this component with Suspense like this:
```
import { Suspense } from 'react';
import BlogPosts from './components/BlogPosts.jsx';
function App() {
  return (
    <>
      <h1>All posts</h1>
      <Suspense fallback={<p>Fetching blog posts...</p>}>
        <BlogPosts />
      </Suspense>
    </>
  );
}

```

Unfortunately, **this will not work in the intended way**, though. Instead of displaying the fallback content, **nothing will be rendered while the data is being fetched**.

The reason for this behavior is that `Suspense` is intended to suspend when fetching data **during the component rendering process** — not when fetching inside of some effect function.

It helps to recall how `useEffect()` works (from Chapter 8, Handling Side Effects): the effect function is executed **after the component function is executed**, i.e., **after the first component render cycle is done**.

As a result, you can’t use Suspense to show fallback content when fetching data via `useEffect()`. 
Instead, in those cases, you need to manually manage and use some loading state in the component that performs the data fetching (i.e., by manually managing different state slices like isLoading—for example, as explained and shown in Chapter 11, Working with Complex State, in the Limitations of `useState()` and Managing State with `useReducer()` sections.


### Fetching Data while Rendering—the Incorrect Way
Since Suspense intends to show fallback content while a component is fetching data during its rendering process, you could try to re-write the `BlogPosts` component to look like this:

```
async function BlogPosts() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  const response = await fetch(
    'https://jsonplaceholder.typicode.com/posts'
  );
  const posts = await response.json();
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

But trying to use this code will yield an error in the browser developer tools:

<img width="571" height="169" alt="image" src="https://github.com/user-attachments/assets/e25a7210-75a7-4849-abfa-65fab1e880e4" />


Figure 17.3: React complains about async components on the client side

React does not support the usage of async/await in client components. Only React Server Components may use that syntax (and therefore return promises). Consequently, regular React projects, which are not set up to support RSCs, can’t use this solution.

Of course, you could come up with a (problematic) alternative solution like this:
```
function BlogPosts() {
  const [posts, setPosts] = useState([]);
  new Promise(() => setTimeout(() => {
    return fetch(
      'https://jsonplaceholder.typicode.com/posts'
    ).then(response => response.json())
     .then(fetchedPosts => setPosts(fetchedPosts));
  }, 3000));
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

But this approach was already discarded in Chapter 8, Handling Side Effects, in the What’s the Problem? section—the code creates an infinite loop.

So, fetching data as part of a component’s rendering process is really difficult when not working with RSCs.


### Getting Suspense Support Is Tricky
Since Suspense requires data fetching to occur during the rendering process, which is difficult to set up manually, the React documentation (https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading) itself mentions that “only Suspense-enabled data sources will activate the Suspense component,” further stating that those data sources include:

- Data fetching with Suspense-enabled frameworks like Relay and Next.js
- Lazy-loading components code with `lazy()`
- Reading the value of a `Promise` with `use()`

On the same page, the official documentation highlights that “Suspense-enabled data fetching without the use of an opinionated framework is not yet supported.”

#### Note

Documentation may change over time—and so may React. But even though the exact wording may differ at the point of time you’re reading this, the way of using Suspense, and the fact that it can’t be used without special libraries or features like lazy(), is highly unlikely to change.

This chapter was written when React 19 was released. You can visit the official changelog of this book to find out whether anything significant has changed since then: https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md.

Therefore, unless you plan on building your own Suspense-enabled library, you either have to stick to using `Suspense` for code-splitting (via `lazy()`), use a third-party framework or library that integrates with Suspense, or explore the usage of that `use()` Hook.

Of course, the `lazy()` function (and how to use it with `Suspense`) was already covered in Chapter 10, Behind the Scenes of React and Optimization Opportunities, in the Reducing Bundle Sizes via Code Splitting (Lazy Loading) section. But what about the other two options: Suspense-enabled libraries and the `use()` Hook?

### Using Suspense for Data Fetching with Supporting Libraries
As you learned in the Using Suspense for Data Fetching with Next.js section, you can use Suspense for data fetching when working with Next.js. But while Next.js is one of the most popular React frameworks that supports Suspense, it’s not the only option you have.

For example, **TanStack Query** (formerly known as React Query) is another popular third-party library **that unlocks Suspense for data fetching**. This library, unlike Next.js, is not a library that aims to help with building full-stack React apps or running code on the server side, though. Instead, TanStack Query is a library that’s all about **helping with client-side data fetching, data mutations, and asynchronous state management**. Since it runs on the client side, it therefore works in React projects that do not integrate with SSR and RSCs, too — although you can also use it in such projects.

TanStack Query is a complex, feature-rich library—we could probably write an entire book about it. But the following short code snippet (which is from a Vite-based project, not from a Next.js project) shows how you may fetch data with the help of that library:

```
import { useSuspenseQuery } from '@tanstack/react-query';
async function fetchPosts() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  const response = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await response.json();
  return posts;
}
function BlogPosts() {
  const {data} = useSuspenseQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts
  });
  return (
    <ul>
      {data.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

In this example, the BlogPosts component uses TanStack Query’s `useSuspenseQuery()` Hook, in conjunction with a custom `fetchPosts()` function, to fetch data via an HTTP request. As the name of the Hook implies, it integrates with React’s Suspense component.

As a result, the `BlogPosts` component can then be wrapped with `Suspense` like this:

```
import { Suspense } from 'react';
import BlogPosts from './components/BlogPosts.jsx';
function App() {
  return (
    <>
      <h1>All posts</h1>
      <Suspense fallback={<p>Fetching blog posts...</p>}>
        <BlogPosts />
      </Suspense>
    </>
  );
}
```

As you can tell, Suspense is used in the same way it was used with lazy() or Next.js. So, its functionality and usage don’t change—if you’re wrapping it around a component that integrates with Suspense (like BlogPost does, via TanStack Query’s useSuspenseQuery() Hook), Suspense can be used to output some fallback content while some data fetching process is underway.

#### Note

You can find the complete example project on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query.

Of course, this is just a simple example. You can do more with TanStack Query, and there also are other libraries that can be used in conjunction with Suspense. It’s just important to understand that there are other options than Next.js. But it’s also crucial to keep in mind that not all code (and also not all libraries) will work with Suspense.

Besides using libraries that directly integrate with Suspense (like TanStack Query via its useSuspenseQuery() Hook), you can also use Suspense for data fetching with the help of React’s built-in `use()` Hook.

### use()ing Data while Rendering
The use() Hook offered by React is not limited to accessing context values, as shown in Chapter 11, Working with Complex State—instead, it may also be used to read values from a promise.

Thus, you can use the use() Hook during a component’s rendering process to extract and use the value of a promise. use() will automatically interact with any wrapping Suspense component and let it know about the current status of the data fetching process (i.e., if the promise has been resolved or not).

The example from the Fetching Data while Rendering — the **Incorrect Way** section can therefore be adjusted to use the `use()` Hook like this:

```
import { use } from 'react';
async function fetchPosts() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  const response = await fetch(
    'https://jsonplaceholder.typicode.com/posts'
  );
  const posts = await response.json();
  return posts;
}
function BlogPosts() {
  const posts = use(fetchPosts());
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

The `BlogPosts` component is now no longer a component that uses `async/await`. Instead, it uses the imported `use()` Hook to read the value of the promise produced by calling `fetchPosts()`.

As mentioned, `use()` interacts with `Suspense`, hence BlogPosts can be wrapped with Suspense like this:
```
import { Suspense } from 'react';
import BlogPosts from './components/BlogPosts.jsx';
function App() {
  return (
    <>
      <h1>All posts</h1>
      <Suspense fallback={<p>Fetching blog posts...</p>}>
        <BlogPosts />
      </Suspense>
    </>
  );
}
```

When running this code, it might work as intended (depending on the React version you’re using), but it’s more likely to not yield any results or even show an error message in the browser developer tools:

<img width="514" height="212" alt="image" src="https://github.com/user-attachments/assets/d2996286-b89c-4b62-9085-88f5757a1cee" />

Figure 17.4: The use() Hook only works with promises created by Suspense-compatible libraries

As explained by this error message, the use() Hook is not intended to be used with regular promises as created in the previous example. Instead, it should be used on promises that are provided by Suspense-compatible libraries or frameworks.

#### Note

If you want to go against the official recommendation and try to build promises that support use() and Suspense, you can explore the official Suspense demo projects linked in the official React documentation (https://19.react.dev/reference/react/Suspense)—for example, this project: https://codesandbox.io/p/sandbox/strange-black-6j7nnj.

Please note that, as mentioned in the documentation, the approach used in that demo project uses unstable APIs and may not work with future React versions.

So, again, support from a third-party framework or library is needed. No matter if you try to use Suspense with components that fetch data as part of the rendering process with or without use(), you end up needing help.

Put in other words: to take advantage of Suspense, you either need to directly fetch data via a Suspense-compatible library or framework, or you need to use the use() Hook on a promise that’s generated by a Suspense-compatible library or framework.

One such framework is, again, Next.js. Besides using Suspense around RSCs, as shown in the section Using suspense for Data Fetching with Next.js, you can also use Suspense in conjunction with the use() Hook on promises produced by Next.js.

### Using use() with Promises Created by Next.js
Next.js projects are able to create promises that will work with use() and Suspense. To be precise, any promise you create in an RSC and pass to a (client) component via props qualifies as a use()able promise.

Consider this example code:
```
import fs from 'node:fs/promises';
import UserGoals from '../../components/UserGoals';
async function fetchGoals() {
  await new Promise((resolve) => setTimeout(resolve, 3000)); // delay
  const goals = await fs.readFile('./data/user-goals.json', 'utf-8');
  return JSON.parse(goals);
}
export default function GoalsPage() {
  const fetchGoalsPromise = fetchGoals();
  return (
    <>
      <h1>Top User Goals</h1>
      <UserGoals promise={fetchGoalsPromise} />
    </>
  );
}
```

In this code snippet, a promise is created by calling fetchGoals() and stored in a constant called fetchGoalsPromise. The created promise (fetchGoalsPromise) is then passed as a value for the promise prop to the UserGoals component.

Along with another component, this UserGoals component is defined in the UserGoals.js file like this:
```
import { use, Suspense } from 'react';
function Goals({ fetchGoalsPromise }) {
  const goals = use(fetchGoalsPromise);
  return (
    <ul>
      {goals.map((goal) => (
        <li key={goal}>{goal}</li>
      ))}
    </ul>
  );
}
export default function UserGoals({ promise }) {
  return (
    <Suspense fallback={<p id="fallback">Fetching user goals...</p>}>
      <Goals fetchGoalsPromise={promise} />
    </Suspense>
  );
}
```

In this code example, the UserGoals component uses Suspense to wrap the Goals component to which it essentially forwards the received promise prop value (via the fetchGoalsPromise prop). The Goals component then reads that promise value via the use() Hook.

Since the promise is created in an RSC (GoalsPage) that’s managed by Next.js, React will not complain about this code—Next.js creates promises that work with use(). Instead, it will show the fallback content (<p id="fallback">Fetching user goals...</p>) while data is being fetched and renders the final user interface once the data has arrived and has been streamed to the client.

As explained before, any elements not wrapped by Suspense (i.e., the <h1> element, in this example) will be displayed right from the start.

<img width="878" height="187" alt="image" src="https://github.com/user-attachments/assets/36ff9b74-9924-406c-b22f-023fcf4de7fd" />
Figure 17.5: The fallback text is shown next to the title while data is fetched via use()

It’s also worth noting that both UserGoals and Goals are RSCs, too—nonetheless, they can use the use() Hook.

Normally, Hooks can’t be used in RSCs but the `use()` Hook is special. Just as **it may be used inside if statements or loops** (as explained in Chapter 11, Working with Complex State), **it can be executed in both server and client components**.

However, when working with a server component, you can also simply use `async/await` instead of `use()`. Thus, the `use()` Hook is really **only useful when it comes to reading promise values in client components** — there, `async/await` is not available.

### Using use() in Client Components
Besides using it for accessing context, the use() Hook was introduced to help with reading values from promises in client components—i.e., in situations where you can’t use async/await.

Consider this updated user goals example, where some state is managed and a side effect is triggered:

```
'use client';
import { use, Suspense, useEffect,useState  } from 'react';
// sendAnalytics() is a dummy function that just logs to the console
import { sendAnalytics } from '../lib/analytics';
function Goals({ fetchGoalsPromise }) {
  const [mainGoal, setMainGoal] = useState();
  const goals = use(fetchGoalsPromise);
  function handleSetMainGoal(goal) {
    setMainGoal(goal);
  }
  return (
    <ul>
      {goals.map((goal) => (
        <li
          key={goal}
          id={goal === mainGoal ? 'main-goal' : undefined}
          onClick={() => handleSetMainGoal(goal)}
        >
          {goal}
        </li>
      ))}
    </ul>
  );
}
export default function UserGoals({ promise }) {
  useEffect(() => {
    sendAnalytics('user-goals-loaded', navigator.userAgent);
  }, []);
  return (
    <Suspense fallback={<p id="fallback">Fetching user goals...</p>}>
      <Goals fetchGoalsPromise={promise} />
    </Suspense>
  );
}
```

In this example, the Goals component uses useState() to manage the information of which goal was marked as the main goal by the user. Furthermore, the UserGoals component (which uses Suspense) utilizes the useEffect() Hook to send an analytics event once the component renders (i.e., before the suspended Goals component is displayed). Due to the usage of all these client-side exclusive features, the 'use client' directive is required.

As a result, async/await can’t be used in the Goals and UserGoals components. But since the use() Hook can be used in client components, it offers a possible solution for situations like this. And, since this example is from a Next.js application, React will not complain about the kind of promise being consumed by use(). Instead, this example code would lead to the fallback content being displayed while the goals data is fetched.

## Suspense Usage Patterns
As you have learned, the Suspense component can be wrapped around **components that fetch data as part of their rendering process** — as long as they do it in a compliant way.

Of course, in many projects, you may have multiple components that fetch data and that should display some fallback content while doing so. Thankfully, you can use the Suspense component as often as needed—you can even combine multiple Suspense components with each other.

### Revealing Content Together
Thus far, in all examples, Suspense was always wrapped around exactly one component. But there is no rule that would stop you from wrapping Suspense around multiple components.

For example, the following code is valid:
```
function Shop() {
  return (
    <>
      <h1>Welcome to our shop!</h1>
      <Suspense fallback={<p>Fetching shop data...</p>}>
        <DailyDeal />
        <Products />
      </Suspense>
    </>
  );
}
```

In this code snippet, data fetching in the DailyDeal and Products components starts simultaneously. Since both components are wrapped by one single Suspense component, the fallback content is displayed unti both components are done fetching data. So, if one component (e.g., DailyDeal) is done after one second, and the other component (Products) takes five seconds, both components are only revealed (and replace the fallback content) after five seconds.

<img width="878" height="416" alt="image" src="https://github.com/user-attachments/assets/fc00852d-9553-4914-8034-3101b9a83b37" />
Figure 17.6: Data is fetched in parallel, and fallback content is shown via Suspense until all components are done

### Revealing Content as Soon as Possible
Of course, there are situations where you might want to display fallback content for multiple components, but where you don’t want to wait for all components to finish fetching data before showing any fetched content.

In such situations, you can use Suspense multiple times:

```
function Shop() {
  return (
    <>
      <h1>Welcome to our shop!</h1>
      <Suspense fallback={<p>Fetching daily deal data...</p>}>
        <DailyDeal />
      </Suspense>
      <Suspense fallback={<p>Fetching products data...</p>}>
        <Products />
      </Suspense>
    </>
  );
}
```

In this adjusted code example, DailyDeal and Products are wrapped with two different instances of the Suspense component. Thus, each component’s content will be revealed once available, independent from the other component’s data fetching status.

### Nesting Suspended Content
Besides fetching in parallel, you can also create more complex loading sequences with nested Suspense components.

Consider this example:
```
function Shop() {
  return (
    <>
      <h1>Welcome to our shop!</h1>
      <Suspense fallback={<p>Fetching shop data...</p>}>
        <DailyDeal />
        <Suspense fallback={<p>Fetching products data...</p>}>
          <Products />
        </Suspense>
      </Suspense>
    </>
  );
}
```

In this case, initially, the paragraph with the text Fetching shop data is displayed. Behind the scenes, data fetching in the DailyDeal and Products components starts.

Once the DailyDeal component is done fetching data, its content is displayed. At the same time, below DailyDeal, the fallback of the nested Suspense block is rendered if the Products component is still fetching data.

Finally, once Products has received its data, the inner Suspense component’s fallback content is removed, and the Products component is rendered instead.


Therefore, as you can see, you can use Suspense multiple times. In addition, you can combine different Suspense components such that you can create exactly the loading sequence and user experience you need.

### Should You Fetch Data via Suspense or useEffect()?
As you learned throughout this chapter, you can use Suspense in conjunction with RSCs, Suspense-enabled libraries, or the use() Hook (which also requires supporting libraries) to fetch data and show some fallback content while data is being fetched.

Alternatively, as covered in Chapter 11, Working with Complex State, you can also fetch data and manually show fallback content via useEffect() and useState() or useReducer(). In that case, you essentially manage the state that determines whether to show some loading fallback content on your own; with Suspense, React does that for you.

Consequently, it’s up to you which approach you prefer. Using Suspense can save you quite a bit of code since you don’t need to manage these different state slices manually. Combined with frameworks like Next.js or libraries like TanStack Query, data fetching can therefore become significantly easier than when doing it manually via useEffect(). In addition, Suspense integrates with RSCs and SSR and therefore can be used to fetch data on the server side—unlike useEffect(), which has no effect (no pun intended) on the server side.

However, if you’re not using any library or framework that supports Suspense or use()-enabled promises, you don’t have much of a choice other than to fall back to useEffect() (and hence not use Suspense for data fetching). This may change with future React versions, since they might provide tools that help with building promises that work with use(). But for the time being, it’s basically a decision between using (the right) libraries and Suspense or no libraries and useEffect().

### Summary and Key Takeaways
- The Suspense component can be used to show fallback content while data is fetched, or code is downloaded.
- For data fetching, Suspense only works with components that fetch data via Suspense-enabled data sources during their rendering process.
- Libraries and frameworks like TanStack Query and Next.js support using Suspense for data fetching.
- Using Next.js, you can wrap Suspense around server components that use async/await.
- Alternatively, Suspense can be wrapped around components that use React’s use() Hook for reading a promise value.
- use() should only be used to read values of promises that resolve with Suspense in mind—e.g., promises created by Suspense-compatible third-party libraries.
- When using Next.js, promises created in RSCs and passed to (client) components via props may be consumed via use().
- The use() Hook helps with reading values and using Suspense in components that also need to use client-specific features like useState().
- Suspense can be wrapped around as many components as needed to fetch data and display content simultaneously.
= Suspense can also be nested to create complex loading sequences.



What’s Next?
React’s Suspense feature can be very useful since it helps with granularly showing fallback content while code or data is being fetched. At the same time, when it comes to data fetching, it can be tricky to use Suspense since it only works with components that fetch data in the correct way (e.g., via the use() Hook, if the promise passed to the Hook is Suspense-compatible).

That’s why this chapter also explored how to use Suspense and use() with Next.js, and how that framework simplifies the process of fetching data and showing fallback content with Suspense and use().

Despite the potential complexity, Suspense can help with creating great user experiences since it allows you to easily show fallback content while a resource is pending.

This chapter also concludes the list of core React features you must know about as a React developer. Of course, you can always dive deeper to explore more patterns and third-party libraries. The next (and last) chapter will share some resources and possible next steps you could dive into after finishing this book.

## Test Your Knowledge!
Test your knowledge of the concepts covered in this chapter by answering the following questions. You can then compare your answers to examples that can be found at https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md:

What’s the purpose of React’s Suspense component?
How do components need to fetch data in order to work with Suspense?
How may Suspense be used when working with Next.js?
What’s the purpose of the use() Hook?
Which kind of promises can be read by the use() Hook?
List three ways of using Suspense with multiple components.
Apply What You Learned
With all the newly gained knowledge about Next.js, it’s time to apply it to a real demo project.

In the following section, you’ll find an activity that allows you to practice working with Next.js and Suspense. As always, you will also need to employ some of the concepts covered in earlier chapters.

## Activity 17.1: Implement Suspense in the Mini Blog
In this activity, your job is to build upon the finished project from Activity 16.1. There, a very simple blog was built. Now, your task is to enhance this blog to show some fallback content while the list of blog posts or the details for an individual blog post are loading. To prove your knowledge, you should fetch data via async/await on the starting page (/), and via the use() Hook on the blog/<some-id> page.

In addition, the list of available blog posts should also be displayed below the details for a single blog post. Of course, while fetching that list data, some fallback text must be displayed—though, that text should be displayed independently from the fallback content for the blog post details.

#### Note

You can find a starting project snapshot for this activity at https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start. When downloading this code, you’ll always download the entire repository. Make sure to then navigate to the subfolder with the starting code (activities/practice-1-start, in this case) to use the right code snapshot.

In the provided starting project, you’ll find functions for fetching all blog posts and a single post. These functions contain artificial delays to simulate slow servers.

After downloading the code and running npm install in the project folder to install all required dependencies, the solution steps are as follows:

Outsource the logic for fetching and displaying a list of posts into a separate component.
Use that component on the starting page and use React’s Suspense component to display some fitting fallback content while the blog posts are being fetched.
Also, outsource the logic for retrieving and rendering the details for a single blog post into a separate client (!) component. Output that newly created component on the /blog/<some-id> page.
Pass a promise for fetching the details of a blog to that newly created component, and use the use() Hook to read its value. Also, take advantage of the Suspense component to output some fallback content.
Re-use the component that fetches and renders a list of blog posts and output it below the blog post details on the /blog/<some-id> page. Use Suspense to show some fallback content, independently from the data fetching status of the blog post details.
The final page should look as shown in the following screenshots:

<img width="878" height="217" alt="image" src="https://github.com/user-attachments/assets/9560e563-8671-483b-9c68-e8e0efffc2ef" />

Figure 17.9: Fallback content is shown while the blog posts are fetched

<img width="878" height="326" alt="image" src="https://github.com/user-attachments/assets/f4abd7b1-86b9-4561-bb80-7fe7b47e6d18" />

Figure 17.10: Fallback content is shown while fetching blog post details and the list of blog posts

#### Note

You can find the full code for this activity, and an example solution, here: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1.
