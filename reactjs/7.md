## Understanding React Suspense & The use() Hook

#### Learning Objectives

By the end of this chapter, you will be able to do the following:

- Describe the purpose and functionality of React’s Suspense feature
- Use Suspense with RSCs to show fallback content on a granular level
- Use Suspense for client components via React’s use() Hook
- Apply different Suspense strategies for data fetching and fallback content


### Introduction
In Chapter 10, Behind the Scenes of React and Optimization Opportunities, in the Reducing Bundle Sizes via Code Splitting (Lazy Loading) section, you learned about React’s `<Suspense>` component and how it may be used in the context of lazy loading and code splitting to show fallback content while a code bundle is being downloaded.

As explained there, the purpose of the Suspense component is to simplify the process of showing fallback content, which, in turn, can lead to a better user experience. Since staring at outdated content or a blank page is not something most users appreciate, having a built-in feature that shows alternative content is very convenient.

In this chapter, you’ll learn that React’s Suspense component is not limited to being used for code splitting. 
Instead, it can also be used for data fetching to show some temporary content while data is being loaded (e.g., from a database). 
Though, as you will also learn, Suspense can only be used for data fetching if the data is fetched in a certain way.

In addition, this chapter will revisit the `use()` Hook, which was introduced in Chapter 11, Working with Complex State. 
As you will learn, besides using it for getting access to context values, this Hook can be used in conjunction with `Suspense` as well.

### Showing Granular Fallback Content with Suspense
When fetching data or downloading a resource (e.g., a code file), loading delays can occur—delays that can lead to a bad user experience. 
You should therefore consider showing some temporary fallback content while waiting for the requested resource.

For that reason, to simplify the process of rendering fallback content while waiting for some resource, React offers its Suspense component. 
As shown in Chapter 10, Behind the Scenes of React and Optimization Opportunities, you can use the Suspense component as a wrapper around React elements that fetch some code or data. 
For example, when using it in the context of code splitting, you can show some temporary fallback content like this:

```
import { lazy, Suspense, useState } from 'react';
const DateCalculator = lazy(() => import(
    './components/DateCalculator.jsx'
  )
);
function App() {
  const [showDateCalc, setShowDateCalc] = useState(false);
  function handleOpenDateCalc() {
    setShowDateCalc(true);
  }
  return (
    <>
      <p>This app might be doing all kinds of things.</p>
      <p>
        But you can also open a calculator which calculates 
        the difference between two dates.
      </p>
      <button onClick={handleOpenDateCalc}>Open Calculator</button>
      <Suspense fallback={<p>Loading...</p>}>
        {showDateCalc && <DateCalculator />}
      </Suspense>
    </>
  );
}
```

In this example (which is from a regular Vite-based React project), React’s `Suspense` component is wrapped around the conditionally rendered `DateCalculator` component. 
`DateCalculator` is created with the help of React’s `lazy()` function, **which is used to lazily (i.e., on demand) load the code bundle** that belongs to this component.

As a result, the entire other page content is shown right from the start. 
Only the conditionally displayed `DateCalculator` component is replaced with the fallback content (`<p>Loading...</p>`) while the code is being fetched. 
Thus, `Suspense` is used to render some fallback JSX code **on a very granular level**. 
Instead of replacing the entire page or component markup with some temporary content, only a small part of the UI is replaced.

Of course, `Suspense` therefore provides a functionality that would also be nice to have when fetching data—after all, delays occur frequently there, too.

### Using Suspense for Data Fetching with Next.js
As explained in the previous chapter, in the Managing Loading States with Next.js section, the process of data fetching also often comes with waiting times that can negatively impact user experience. 
That’s why, in that same section, you learned that Next.js allows you to define a `loading.js` file that contains some fallback component that’s rendered during such a delay.

However, using that approach **essentially replaces the entire page (or the main area of that page)** with the loading fallback component content. 
But that’s not always ideal—you instead might want to display some loading fallback content on a more granular level when fetching data.

Thankfully, in Next.js projects, you can use `Suspense` in a similar way, as shown in the example from the previous section, to wrap it around components that fetch data. 
Since Next.js supports HTTP response streaming, it’s able to render the rest of the page immediately while streaming the content that depends on the fetched data to the client side once it’s available. 
Until the data is loaded and available, `Suspense` will render its defined fallback.

Therefore, coming back to the example from the Managing Loading States with Next.js section of Chapter 16, React Server Components & Server Actions, you can take advantage of `Suspense` by outsourcing the data fetching code into a separate UserGoals component:

```
import fs from 'node:fs/promises';
async function fetchGoals() {
  await new Promise((resolve) => setTimeout(resolve, 3000)); // delay
  const goals = await fs.readFile('./data/user-goals.json', 'utf-8');
  return JSON.parse(goals);
}
export default async function UserGoals() {
  const fetchedGoals = await fetchGoals();
  return (
    <ul>
      {fetchedGoals.map((goal) => (
        <li key={goal}>{goal}</li>
      ))}
    </ul>
  );
}
```

This `UserGoals` component can then be wrapped with `Suspense` in the `GoalsPage` component like this:
```
import { Suspense } from 'react';
import UserGoals from '../../components/UserGoals';
export default async function GoalsPage() {
  return (
    <>
      <h1>Top User Goals</h1>
      <Suspense fallback={
        <p id="fallback">Fetching user goals...</p>}
      >
        <UserGoals />
      </Suspense>
    </>
  );
}

```

This code now utilizes React’s Suspense component to show a fallback paragraph while the UserGoals component is fetching data.

#### Note

You can find the complete demo project code on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense.

As a result, when users navigate to `/goals`, they immediately see the title (the `<h1>` element) in combination with the fallback content. There is no need for a separate `loading.js` file anymore.

<img width="877" height="195" alt="image" src="https://github.com/user-attachments/assets/0d102779-be65-4489-8783-e176e25407e0" />

Figure 17.1: The fallback content is shown as part of the target page, instead of entirely replacing it

However, the advantage of using Suspense in this situation is not just that the loading.js file isn’t needed anymore. Instead, data fetching and fallback content can now be managed on a very granular level.

For example, in a more complex online shop application, you could have a component like this:

```
function ShopOverviewPage() {
  return (
    <>
      <header>
        <h1>Find your next deal!</h1>
        <MainNavigation />
      </header>
      <main>
        <Suspense fallback={<DailyDealSkeleton />}>
          <DailyDeal />
        </Suspense>
        <section id="search">
          <h2>Looking for something specific?</h2>
          <Search />
        </section>
        <Suspense fallback={<p>Fetching products...</p>}>
          <Products />
        </Suspense>
      </main>
    </>
  );
}
```

In this example, the <header> and <section id="search"> elements are always visible and rendered. 
On the other hand, <DailyDeal /> and <Products /> are only rendered once their data has been fetched. Until then, their respective fallbacks are displayed.

<img width="877" height="520" alt="image" src="https://github.com/user-attachments/assets/80d5030d-d583-4aaa-a38c-6df842288213" />

Figure 17.2: Placeholders are shown initially until loaded data is streamed in and rendered to the screen

`<DailyDeal />` and `<Products />` will be loaded and rendered independently from each other since they’re wrapped by two different `Suspense` blocks. 
Consequently, users will immediately see the header and search area, and then eventually see the daily deal and products—though either of the two may load and render first.

What’s important about these examples is that the components wrapped by Suspense are RSCs that use `async/await`. 
As you will learn in the next section, **not all React components will interact with the Suspense component**. But React Server Components, in Next.js projects, will.

### Using Suspense in Other React Projects—Possible, But Tricky
The previous section explored how you may take advantage of Suspense for data fetching with RSCs in Next.js projects.

However, Suspense is not a Next.js-specific feature or concept—instead, it’s provided by React itself. Consequently, you can use it in any React project to show fallback content while data is being fetched.

At least, that’s the theory. But as it turns out, you can’t use it with all components and data fetching strategies.

### Suspense Does Not Work with useEffect()
Since fetching data via `useEffect()` is a common strategy, you might be inclined to use Suspense in conjunction with this Hook to show some fallback content while data is being loaded via the effect function.

For example, the following BlogPosts components uses `useEffect()` to load and display some blog posts:

```
import { useEffect, useState } from 'react';
function BlogPosts() {
  const [posts, setPosts] = useState([]);
  useEffect(() => {
    async function fetchBlogPosts() {
      // simulate slow network
      await new Promise((resolve) => setTimeout(resolve, 3000));
      const response = await fetch(
        'https://jsonplaceholder.typicode.com/posts'
      );
      const posts = await response.json();
      setPosts(posts);
    }
    fetchBlogPosts();
  }, []);
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

You could wrap this component with Suspense like this:
```
import { Suspense } from 'react';
import BlogPosts from './components/BlogPosts.jsx';
function App() {
  return (
    <>
      <h1>All posts</h1>
      <Suspense fallback={<p>Fetching blog posts...</p>}>
        <BlogPosts />
      </Suspense>
    </>
  );
}

```

Unfortunately, **this will not work in the intended way**, though. Instead of displaying the fallback content, **nothing will be rendered while the data is being fetched**.

The reason for this behavior is that `Suspense` is intended to suspend when fetching data **during the component rendering process** — not when fetching inside of some effect function.

It helps to recall how `useEffect()` works (from Chapter 8, Handling Side Effects): the effect function is executed **after the component function is executed**, i.e., **after the first component render cycle is done**.

As a result, you can’t use Suspense to show fallback content when fetching data via `useEffect()`. 
Instead, in those cases, you need to manually manage and use some loading state in the component that performs the data fetching (i.e., by manually managing different state slices like isLoading—for example, as explained and shown in Chapter 11, Working with Complex State, in the Limitations of `useState()` and Managing State with `useReducer()` sections.


### Fetching Data while Rendering—the Incorrect Way
Since Suspense intends to show fallback content while a component is fetching data during its rendering process, you could try to re-write the `BlogPosts` component to look like this:

```
async function BlogPosts() {
  await new Promise((resolve) => setTimeout(resolve, 3000));
  const response = await fetch(
    'https://jsonplaceholder.typicode.com/posts'
  );
  const posts = await response.json();
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

But trying to use this code will yield an error in the browser developer tools:

<img width="571" height="169" alt="image" src="https://github.com/user-attachments/assets/e25a7210-75a7-4849-abfa-65fab1e880e4" />


Figure 17.3: React complains about async components on the client side

React does not support the usage of async/await in client components. Only React Server Components may use that syntax (and therefore return promises). Consequently, regular React projects, which are not set up to support RSCs, can’t use this solution.

Of course, you could come up with a (problematic) alternative solution like this:






































