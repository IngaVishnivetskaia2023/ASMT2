
## Handling Side Effects

### What‚Äôs the Problem?
Before exploring a solution, it‚Äôs important to first understand the concrete problem.

Actions **that are not directly related to producing a (new) user interface state often clash with React‚Äôs component rendering cycle**. They may introduce bugs or even break the entire web app.

Consider the following example code snippet (important: don‚Äôt execute this code as it will cause an infinite loop and send a large number of HTTP requests behind the scenes):

```
import { useState } from 'react';
import classes from './BlogPosts.module.css';
async function fetchPosts() {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts');
  const blogPosts = await response.json();
  return blogPosts;
}
function BlogPosts() {
  const [loadedPosts, setLoadedPosts] = useState([]);
  fetchPosts().then((fetchedPosts) => setLoadedPosts(fetchedPosts));
  return (
    <ul className={classes.posts}>
      {loadedPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
export default BlogPosts;
```

So what‚Äôs the problem with this code? Why does it create an infinite loop?

In this example, a React component (`BlogPosts`) is created. In addition, a non-component function (`fetchPosts()`) is defined. 
That function uses the built-in `fetch()` function (provided by the browser) to send an HTTP request to an external application programming interface (API) and fetch some data.

In the preceding code snippet, the `BlogPosts` component utilizes `useState()` to register a `loadedPosts` state value. 
The state is used to output a list of blog posts. Those blog posts are not defined in the app itself though. Instead, they are fetched from the external API mentioned in the note box.

`fetchPosts()`, which is the utility function that contains the code for fetching blog posts data from that backend API using the built-in `fetch()` function, is called directly in the component function body. 
Since `fetchPosts()` is an async function (using `async/await`), it returns a **promise**. 
In `BlogPosts`, the code that should be executed once **the promise resolves** is registered via the built-in `then()` method.

‚ùó 
#### Note

`async/await` is **not used directly in the component function body** because regular React components **must not be async functions**. 
Such functions automatically return a promise as a value (even without an explicit return statement), which is an **invalid** return value for a React component.

That being said, there are indeed React components that are allowed to use async/await and return a promise. 
So-called **React Server Components** are not restricted to returning JSX code, strings, etc. 
This feature will be discussed in detail in Chapter 16, React Server Components & Server Actions.

Once the `fetchPosts()` promise resolves, the extracted posts data (`fetchedPosts`) is set as the new `loadedPosts` state (via `setLoadedPosts(fetchedPosts)`).

If you were to run the preceding code (which you should not do!), it would at first seem to work. But behind the scenes, it would **actually start an infinite loop, hammering the API with HTTP requests**. 
This is because, as a result of getting a response from the HTTP request, `setLoadedPosts()` is used to set a new state.

Earlier in this book (in Chapter 4, Working with Events and State), you learned that **whenever the state of a component changes, React re-evaluates the component to which the state belongs**. 
‚ÄúRe-evaluating‚Äù simply means that the component function is executed again (by React, automatically).

Since this `BlogPosts` component calls `fetchPosts()` (which sends an HTTP request) directly inside the component function body, this HTTP request will be sent every time the component function is executed. 
And as the state (`loadedPosts`) is updated as a result of getting a response from that HTTP request, this process begins again, and an infinite loop is created.

The root problem, in this case, is that **sending an HTTP request is a side effect**‚Äîa concept that will be explored in greater detail in the next section.

### Understanding Side Effects
Side effects are actions or processes that occur in addition to another main process. 
At least, this is a concise definition that helps with understanding side effects in the context of a React app.

üóíÔ∏è If you want to dive deeper into the concept of side effects, you can also explore the following discussion about side effects on Stack Overflow: https://softwareengineering.stackexchange.com/questions/40297/what-is-a-side-effect.

For this, React considers state changes as the trigger for updating the user interface. Registering event handlers such as onClick, adding refs, or rendering child components (possibly by using props) would be other elements that belong to this main process‚Äîbecause all these concepts are directly related to the main task of rendering the desired user interface.

Sending an HTTP request, as in the preceding example, is not part of this main process, though. It doesn‚Äôt directly influence the user interface. While the response data might eventually be output on the screen, it definitely won‚Äôt be used in the exact same component render cycle in which the request is sent (because HTTP requests are asynchronous tasks).

Since sending the HTTP request is not part of the main process (rendering the user interface) that‚Äôs performed by the component function, it‚Äôs considered a side effect. It‚Äôs invoked by the same function (the BlogPosts component function), which primarily has a different goal.

**If the HTTP request were sent upon a click of a button rather than as part of the main component function body, it would not be a side effect**. Consider this example:
```
import { useState } from 'react';
import classes from './BlogPosts.module.css';
async function fetchPosts() {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts');
  const blogPosts = await response.json();
  return blogPosts;
}
function BlogPosts() {
  const [loadedPosts, setLoadedPosts] = useState([]);
  function handleFetchPosts() {
    fetchPosts().then((fetchedPosts) => setLoadedPosts(fetchedPosts));
  }
  return (
    <>
      <button onClick={handleFetchPosts}>Fetch Posts</button>
      <ul className={classes.posts}>
        {loadedPosts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </>
  );
}
export default BlogPosts;
```

This code is almost identical to the previous example, but it has one important difference: a `<button>` was added to the JSX code. And it‚Äôs this button that invokes a newly added `handleFetchPosts()` function, which then sends the HTTP request (and updates the state).

With this change made, the HTTP request is not sent every time the component function re-renders (that is, is executed again). Instead, it‚Äôs only sent whenever the button is clicked, and therefore, this does not create an infinite loop. The HTTP request, in this case, also doesn‚Äôt postulate a side effect, because the primary goal of `handleFetchPosts()` (i.e., the main process) is to fetch new posts and update the state.

#### Here‚Äôs a non-exhaustive list of examples of side effects:

- Sending an HTTP request (as shown previously)
- Storing data to or fetching data from browser storage (for example, via the built-in `localStorage` object)
- Setting timers (via `setTimeout()`) or intervals (via `setInterval()`)
- Logging data to the console via `console.log()`

Not all side effects cause infinite loops, however. Such loops only occur if the side effect leads to a state update.

Here‚Äôs an example of a side effect that would not cause an infinite loop:
```
function ControlCenter() {
  function handleStart() {
    // do something ...
  }
  console.log('Component is rendering!'); // this is a side effect!
  return (
    <div>
      <p>Press button to start the review process</p>
      <button onClick={handleStart}>Start</button>
    </div>
  );
}
```

In this example, `console.log(‚Ä¶)` is a side effect because it‚Äôs executed as part of every component function execution and does not influence the rendered user interface (neither for this specific render cycle nor indirectly for any future render cycles in this case, unlike the previous example with the HTTP request).

Of course, using `console.log()` like this is not causing any problems. During development, it‚Äôs quite normal to log messages or data for debugging purposes. Side effects aren‚Äôt necessarily a problem and, indeed, side effects like this can be used or tolerated.

But you also often need to deal with side effects such as the HTTP request from before. Sometimes, you need to fetch data when a component renders‚Äîprobably not for every render cycle, but typically the first time it is executed (that is, when its generated user interface appears on the screen for the first time).

React offers a solution for this kind of problem as well.

### Dealing with Side Effects with the useEffect() Hook

In order to deal with side effects such as the HTTP request shown previously in a safe way (that is, without creating an infinite loop), React offers another core Hook: the `useEffect()` Hook.

The first example can be fixed and rewritten like this:

```
import { useState, useEffect } from 'react';
import classes from './BlogPosts.module.css';
async function fetchPosts() {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts');
  const blogPosts = await response.json();
  return blogPosts;
}
function BlogPosts() {
  const [loadedPosts, setLoadedPosts] = useState([]);
  useEffect(function () {
    fetchPosts().then((fetchedPosts) => setLoadedPosts(fetchedPosts));
  }, []);
  return (
    <ul className={classes.posts}>
      {loadedPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
export default BlogPosts;
```

In this example, the `useEffect()` Hook is imported and used to control the side effect (hence the name of the Hook, `useEffect()`, as it deals with side effects in React components).

`useEffect()` is therefore the solution for problems like the one outlined previously. It helps you **deal with side effects** so that you can avoid infinite loops and **extract them from your component function‚Äôs main process**.

But how does `useEffect() work`, and how is it used correctly?

### How to Use useEffect()
As shown in the previous example code snippet, `useEffect()`, like all React Hooks, is executed as a function inside the component function (`BlogPosts`, in this case).

Although, unlike `useState()` or `useRef()`, `useEffect()` does not return a value, though it does accept an argument (or, actually, two arguments) like those other Hooks. The first argument is always a function. In this case, the function passed to `useEffect()` is an anonymous function, created via the function keyword.

Alternatively, you could also provide an anonymous function created as an arrow function (`useEffect(() => { ‚Ä¶ })`) or point at some named function (`useEffect(doSomething)`). The only thing that matters is that the first argument passed to `useEffect()` **must be a function**. It must not be any other kind of value.

In the preceding example, `useEffect()` also receives a second argument: an empty array (`[]`). The second argument **must be an array**, but providing it is optional. You could also omit the second argument and just pass the first argument (the function) to `useEffect()`. However, in most cases, the second argument is needed to achieve the correct behavior. Both arguments and their purpose will be explored in greater detail as follows.

The first argument is a function that will be executed by React. **It will be executed after every component render cycle (that is, after every component function execution)**.

**In the preceding example, if you only provide this first argument and omit the second, you will therefore still create an infinite loop**. There will be an (invisible) timing difference because the HTTP request will now be sent **after** every component function execution (instead of as part of it), but you will still trigger a state change, which will still trigger the component function to execute again. Therefore, the effect function will run again, and an infinite loop will be created. In this case, the side effect will be extracted out of the component function technically, but the problem with the infinite loop will not be solved:

```
useEffect(function () {
  fetchPosts().then((fetchedPosts) => setLoadedPosts(fetchedPosts));
}); // this would cause an infinite loop again!
```

Extracting side effects out of React component functions is the main job of `useEffect()`, and so only the first argument (the function that contains the side effect code) is mandatory. But, as mentioned previously, you will also **typically need the second argument to control the frequency with which the effect code will be executed**, because that‚Äôs what the second argument (an array) will do.

The second parameter received by `useEffect()` is always an array (unless it‚Äôs omitted). This array specifies the dependencies of the effect function. Any dependency specified in this array will, once it changes, cause the effect function to execute again. If no array is specified (that is, if the second argument is omitted), the effect function will be executed again for every component function execution:
```
useEffect(function () {
  fetchPosts().then((fetchedPosts) => setLoadedPosts(fetchedPosts));
}, []);
```

In the preceding example, the second argument was not omitted, but it‚Äôs an empty array. This informs React that this effect function has no dependencies. Therefore, the effect function will never be executed again. Instead, it will only be executed **once**, when the component is rendered for the first time. If you set no dependencies (by providing an empty array), React will execute the effect function once‚Äîdirectly after the component function was executed for the first time.

It‚Äôs important to note that specifying an empty array is very different from omitting it. If it is omitted, no dependency information is provided to React. Therefore, React executes the effect function after every component re-evaluation. If an empty array is provided instead, you explicitly state that this effect has no dependencies and therefore should only run once.

This brings up another important question, though: when should you add dependencies? And how exactly are dependencies added or specified?


### Effects and Their Dependencies
Omitting the second argument to `useEffect()` causes the effect function (the first argument) to execute after **every** component function execution. Providing an **empty** array causes the effect function to run only **once** (after the first component function invocation). But is that all you can control?

No, it isn‚Äôt.

The array passed to `useEffect()` can and should contain **all variables, constants, or functions that are used inside the effect function**‚Äîif those variables, constants, or functions **were defined inside the component function** (or in some parent component function, passed down via props).

Consider this example:
```
import { useState, useEffect } from 'react';
import classes from './BlogPosts.module.css';
async function fetchPosts(url) {
  const response = await fetch(url);
  const blogPosts = await response.json();
  return blogPosts;
}
function BlogPosts({ url }) {
  const [loadedPosts, setLoadedPosts] = useState([]);
  useEffect(function () {
    fetchPosts(url)
     .then((fetchedPosts) => setLoadedPosts(fetchedPosts));
  }, [url]);
  return (
    <ul className={classes.posts}>
      {loadedPosts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
export default BlogPosts;
```

This example is based on the previous example, but was adjusted in one important place: BlogPosts now accepts a url prop.

Therefore, this component can now be used and configured by other components. Of course, if some other component sets a URL that doesn‚Äôt return a list of blog posts, the app won‚Äôt work as intended. This component therefore might be of limited practical use, but it does show the importance of effect dependencies quite well.

But if that other component changes the URL (e.g., due to some user input there), a new request should be sent, of course. So BlogPosts should send another fetch request every time the url prop value changes.

That‚Äôs why url was added to the dependencies array of useEffect(). If the array had been kept empty, the effect function would only run once (as described in the previous section). Therefore, any changes to url wouldn‚Äôt have any effect (no pun intended) on the effect function or the HTTP request executed as part of that function. No new HTTP request would be sent.

By adding url to the dependencies array, React registers this value (in this case, a prop value, but any value can be registered) and re-executes the effect function whenever that value changes (that is, whenever a new url prop value is set by the component that uses BlogPosts).

The most common types of effect dependencies are state values, props, and functions that might be executed inside of the effect function. The latter will be analyzed in greater depth later in this chapter.

As a rule, you should add all values (including functions) that are used inside an effect function to the effect dependencies array.

With this new knowledge in mind, if you take another look at the preceding useEffect() example code, you might spot some missing dependencies:

```
useEffect(function () {
  fetchPosts(url)
    .then((fetchedPosts) => setLoadedPosts(fetchedPosts));
}, [url]);
```

Why are `fetchPosts`, `fetchedPosts`, and `setLoadedPosts` not added as dependencies? 
These are, after all, values and functions used inside of the effect function. The next section will address this in detail.

### Unnecessary Dependencies
In the previous example, it might seem as if `fetchPosts`, `fetchedPosts`, and `setLoadedPosts` should be added as dependencies to `useEffect()`, as shown here:
```
useEffect(function () {
  fetchPosts(url)
    .then((fetchedPosts) => setLoadedPosts(fetchedPosts));
}, [url, fetchPosts, fetchedPosts, setLoadedPosts]);

```

However, for `fetchPosts` and `fetchedPosts`, this would be **incorrect**. And for `setLoadedPosts`, it would be unnecessary.

`fetchedPosts` should not be added because **it‚Äôs not an external dependency**. It‚Äôs a local variable (or **argument**, to be precise), defined and used inside the effect function. It‚Äôs not defined in the component function to which the effect belongs. If you try to add it as a dependency, you‚Äôll get an error.

`fetchPosts`, the function that sends the actual HTTP request, is not a function defined **inside** of the effect function. 
But it still **shouldn‚Äôt be added** because it is defined **outside the component function**.

Therefore, there is no way for this function to change. It‚Äôs defined once (in the `BlogPosts.jsx` file), and it can‚Äôt change. That said, this would not be the case if it were defined inside the component function. In that case, whenever the component function executes again, the `fetchPosts` function would be recreated as well. This is a scenario that will be discussed later in this chapter (in the Functions as Dependencies section).

In this example though, `fetchPosts` can‚Äôt change. Therefore, it doesn‚Äôt have to be added as a dependency (and consequently should not be). The same would be true for functions, or any kind of values, provided **by the browser or third-party packages**. Any value that‚Äôs not defined inside a component function shouldn‚Äôt be added to the dependencies array.

‚ùó 
#### Note

It may be confusing that a function could change‚Äîafter all, the logic is hardcoded, right? But in JavaScript, functions are actually **just objects and therefore may change**. 
When the code that contains a function is executed again (e.g., a component function being executed again by React), a new function object will be created in memory.

If this is not something you‚Äôre familiar with, the following resource should be helpful: https://academind.com/tutorials/javascript-functions-are-objects.

So `fetchedPosts` and `fetchPosts` should both not be added (for different reasons). What about `setLoadedPosts`?

`setLoadedPosts` is the state updating function returned by `useState()` for the `loadedPosts` state value. Therefore, like `fetchPosts`, it‚Äôs a function. Unlike `fetchPosts`, though, it‚Äôs a function that‚Äôs defined inside the component function (because `useState()` is called inside the component function). It‚Äôs a function created by React (since it‚Äôs returned by `useState()`), but it‚Äôs still a function. **Theoretically, it should therefore be added as a dependency**. And indeed, you can add it **without any negative consequences**.

But state updating functions returned by `useState()` are a special case: React guarantees that those functions will never change or be recreated. When the surrounding component function (`BlogPosts`) is executed again, `useState()` also executes again. However, a new state updating function is only created the first time a component function is called by React. Subsequent executions don‚Äôt lead to a new state updating function being created.

Because of this special behavior (i.e., **React guaranteeing that the function itself never changes**), state updating functions **may (and actually should) be omitted from the dependencies array**.

For all these reasons, `fetchedPosts`, `fetchPosts`, and `setLoadedPosts` should all not be added to the dependencies array of `useEffect()`. `url` is the only dependency used by the effect function that may change (that is, when the user enters a new URL into the input field) and therefore should be listed in the array.

To sum it up, when it comes to adding values to the effect dependencies array, there are three kinds of exceptions:

- Internal values (or functions) that are defined and used **inside the effect** (such as `fetchedPosts`)
- External values that are **not defined inside a component** function (such as `fetchPosts`)
- State updating functions (such as `setLoadedPosts`)

**In all other cases, if a value is used in the effect function, it must be added to the dependencies array!** Omitting values incorrectly can lead to unexpected effect executions (that is, an effect executing too often or not often enough).

### Cleaning Up after Effects
To perform a certain task (for example, sending an HTTP request), many effects should simply be triggered when their dependencies change. While some effects can be re-executed multiple times without issue, there are also effects that, if they execute again before the previous task has finished, are an indication that the task performed needs to be canceled. Or, maybe there is some other kind of cleanup work that should be performed when the same effect executes again.

Here‚Äôs an example, where an effect sets a timer:
```
import { useState, useEffect } from 'react';
function Alert() {
  const [alertDone, setAlertDone] = useState(false);
  useEffect(function () {
    console.log('Starting Alert Timer!');
    setTimeout(function () {
      console.log('Timer expired!');
      setAlertDone(true);
    }, 2000);
  }, []);
  return (
    <>
      {!alertDone && <p>Relax, you still got some time!</p>}
      {alertDone && <p>Time to get up!</p>}
    </>
  );
}
export default Alert;
```

This `Alert` component is used in the `App` component:
```
import { useState } from 'react';
import Alert from './components/Alert.jsx';
function App() {
  const [showAlert, setShowAlert] = useState(false);
  function handleShowAlert() {
    // state updating is done by passing a function to setShowAlert
    // because the new state depends on the previous state (it's the opposite)
    setShowAlert((isShowing) => !isShowing);
  }
  return (
    <>
      <button onClick={handleShowAlert}>
        {showAlert ? 'Hide' : 'Show'} Alert
      </button>
      {showAlert && <Alert />}
    </>
  );
}
export default App;
```

In the App component, the Alert component is shown conditionally. The showAlert state is toggled via the handleShowAlert function (which is triggered upon a button click).

In the Alert component, a timer is set using useEffect(). Without useEffect(), an infinite loop would be created, since the timer, upon expiration, changes some component state (the alertDone state via the setAlertDone state updating function).

The dependency array is an empty array because this effect function does not use any component values, variables, or functions. console.log() and setTimeout() are functions built into the browser (and therefore external functions), and setAlertDone() can be omitted because of the reasons mentioned in the previous section.

If you run this app and then start toggling the alert (by clicking the button), you‚Äôll notice strange behavior. The timer is set every time the Alert component is rendered. But it‚Äôs not clearing the existing timer. This is due to the fact that multiple timers are running simultaneously, as you can clearly see if you look at the JavaScript console in your browser‚Äôs developer tools.

<img width="880" height="343" alt="image" src="https://github.com/user-attachments/assets/6097697c-5e64-4263-93db-34c9da511855" />

This example is deliberately kept simple, but there are other scenarios in which you may have an ongoing HTTP request that should be aborted before a new one is sent. There are cases like that, where an effect should be cleaned up first before it runs again.

React also provides a solution for those kinds of situations: the effect function passed as a first argument to useEffect() can return an optional cleanup function. If you do return a function inside your effect function, React will execute that function **every time BEFORE it runs the effect again**.

Here‚Äôs the useEffect() call of the Alert component with a cleanup function being returned:
```
useEffect(function () {
  let timer;
  console.log('Starting Alert Timer!');
  timer = setTimeout(function () {
    console.log('Timer expired!');
    setAlertDone(true);
  }, 2000);
  return function() {
    clearTimeout(timer);
  }
}, []);
```

In this updated example, a new timer variable (a local variable that is only accessible inside the effect function) is added. That variable stores a reference to the timer that‚Äôs created by setTimeout(). This reference can then be used together with clearTimeout() to remove a timer.

The timer is removed in a function returned by the effect function‚Äîwhich is the cleanup function that will be executed automatically by React before the effect function is called the next time.

You can see the cleanup function in action if you add a console.log() statement to it:

```
return function() {
  console.log('Cleanup!');
  clearTimeout(timer);
}
```

In your JavaScript console, this looks as follows:

<img width="878" height="361" alt="image" src="https://github.com/user-attachments/assets/5c00a096-b30d-43d8-a1b9-ec051a713895" />

In the preceding screenshot, you can see that **the cleanup function is executed (indicated by the Cleanup! log) right before the effect function is executed again**. You can also see that the timer is cleared successfully: the first timer never expires (there is no Timer expired! log for the first timer in the screenshot).

The cleanup function is not executed when the effect function is called for the first time. However, it will be called by React whenever a component that contains an effect **unmounts (that is, when it‚Äôs removed from the DOM)**.

If an effect has multiple dependencies, the effect function will be executed whenever any of the dependency values change. Therefore, the cleanup function will also be called every time some dependency changes.

### Dealing with Multiple Effects
Thus far, all the examples in this chapter have dealt with only one useEffect() call. You are not limited to only one call per component though. You can call useEffect() as often as needed‚Äîand can therefore register as many effect functions as needed.

#### But how many effect functions do you need?

You could start putting every side effect into its own `useEffect()` wrapper. You could put every HTTP request, every console.log() statement, and every timer into separate effect functions.

That said, as you can see in some of the previous examples‚Äîspecifically, the code snippet in the previous section‚Äîthat‚Äôs not necessary. There, you have multiple effects in one useEffect() call (three console.log() statements and one timer).

A better approach would be to split your effect functions by dependencies. If one side effect depends on state `A` and another side effect depends on state `B`, you could put them into separate effect functions (unless those two states are related), as shown here:

```
function Demo() {
  const [a, setA] = useState(0); // state updating functions aren't called
  const [b, setB] = useState(0); // in this example
  useEffect(function() {
    console.log(a);
  }, [a]);  
 
  useEffect(function() {
    console.log(b);
  }, [b]);
  // return some JSX code ...
}
```

But the best approach is to split your effect functions **by logic**. If one effect deals with fetching data via an HTTP request and another effect is about setting a timer, it will often make sense to put them into different effect functions (that is, different `useEffect()` calls).

### Functions as Dependencies
Different effects have different kinds of dependencies, and one common kind of dependency is functions.

As mentioned previously, functions in JavaScript are just objects. Therefore, whenever some code that contains a function definition is executed, a new function object is created and stored in memory. When calling a function, it‚Äôs that specific function object in memory that is executed. In some scenarios (for example, for functions defined in component functions), it‚Äôs possible that multiple objects based on the same function code exist in memory.

‚ùó Because of this behavior, functions that are referenced in code are not necessarily equal, even if they are based on the same function definition.

Consider this example:
```
function Alert() {
  function setAlert() {
    setTimeout(function() {
      console.log('Alert expired!');
    }, 2000);
  }
  useEffect(function() {
    setAlert();
  }, [setAlert]);
  // return some JSX code ...
}
```

In this example, instead of creating a timer directly inside the effect function, a separate `setAlert()` function is created in the component function. That `setAlert()` function is then used in the effect function passed to `useEffect()`. Since that function is used there, and because it‚Äôs defined in the component function, it should be added as a dependency to `useEffect()`.

Another reason for this is that every time the `Alert` component function **is executed again** (e.g., because some state or prop value changes), a **new** `setAlert` **function object will be created**. In this example, that wouldn‚Äôt be problematic because `setAlert` only contains static code. A new function object created for `setAlert` would work exactly in the same way as the previous one; therefore, it would not matter.

But now consider this adjusted example:

üìì The complete app can be found on GitHub at https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/function-dependencies.

```
function Alert() {
  const [alertMsg, setAlertMsg] = useState('Expired!');
  function handleChangeAlertMsg(event) {
    setAlertMsg(event.target.value);
  }
  function setAlert() {
    setTimeout(function () {
      console.log(alertMsg);
    }, 2000);
  }
  useEffect(
    function () {
      setAlert();
    },
    []
  );
  return <input type="text" onChange={handleChangeAlertMsg} />;
}
export default Alert;
```

Now, a new `alertMsg` state is used for setting the actual alert message that‚Äôs logged to the console. In addition, the `setAlert` dependency was removed from `useEffect()`.

If you run this code, you‚Äôll get the following output:

<img width="877" height="283" alt="image" src="https://github.com/user-attachments/assets/016faf55-911d-4e34-8c81-2769a5f2443e" />

In this screenshot, you can see that, despite a different value being entered into the input field, the original alert message is output.

The reason for this behavior is that the new alert message is not picked up. It‚Äôs not used because, despite the component function being executed again (because the state changed), the effect is not executed again. And the original execution of the effect still uses the old version of the setAlert function‚Äîthe old setAlert function object, which has the old alert message locked in. That‚Äôs how JavaScript functions work, and that‚Äôs why, in this case, the desired result is not achieved.

The solution to the problem is simple though: add `setAlert` as a dependency to `useEffect()`. You should always add all values, variables, or functions **used in an effect** as dependencies, and this example shows **why** you should do that. **Even functions can change**.

If you add setAlert to the effect dependency array, you‚Äôll get a different output:
```
useEffect(
  function () {
    setAlert();
  },
  [setAlert]
);
```
Please note that only a **pointer** to the `setAlert` function is added. You don‚Äôt execute the function in the dependencies array (that would add the return value of the function as a dependency, which is typically not the goal).

<img width="877" height="396" alt="image" src="https://github.com/user-attachments/assets/5605005d-7da7-46e7-9b92-009e3452dadb" />

Now, a new timer is started for every keystroke, and as a result, the entered message is output in the console.

Of course, this might also not be the desired result. You might only be interested in the final error message that was entered. This can be achieved by adding a cleanup function to the effect (and adjusting setAlert a little bit):

```
function setAlert() {
  return setTimeout(function () {
    console.log(alertMsg);
  }, 2000);
}
useEffect(
  function () {
    const timer = setAlert();
    return function () {
      clearTimeout(timer);
    };
  },
  [setAlert]
);
```

As shown in the Cleaning Up after Effects section, the timer is cleared with the help of a timer reference and clearTimeout() in the effect‚Äôs cleanup function.

After adjusting the code like this, only the final alert message that was entered will be output.

Seeing the cleanup function in action again is helpful; the main takeaway is the importance of adding all dependencies, though‚Äîincluding function dependencies.

An alternative to including the function as a dependency would be to move the entire function definition into the effect function, because any value that‚Äôs defined and used inside of an effect function must not be added as a dependency:

```
useEffect(
  function () {
    function setAlert() {
      return setTimeout(function () {
        console.log(alertMsg);
      }, 2000);
    }
    const timer = setAlert();
    return function () {
      clearTimeout(timer);
    };
  },
  []
);
```

Of course, you could also get rid of the setAlert function altogether then and just move the function‚Äôs code into the effect function.

Either way, you will have to add a new dependency, alertMsg, which is now used inside of the effect function. Even though the setAlert function isn‚Äôt a dependency anymore, you still must add any values used (and alertMsg is used in the effect function now):
```
useEffect(
  function () {
    function setAlert() {
      return setTimeout(function () {
        console.log(alertMsg);
      }, 2000);
    }
    const timer = setAlert();
    return function () {
      clearTimeout(timer);
    };
  },
  [alertMsg]
);
```

Hence, this alternative way of writing the code just comes down to personal preferences. It does not reduce the number of dependencies.

You would get rid of a function dependency if you were to move the function out of the component function. This is because, as mentioned in the Unnecessary Dependencies section, external dependencies (for example, those built into the browser or defined outside of component functions) should not be added as dependencies.

However, in the case of the setAlert function, this is not possible because setAlert uses alertMsg. Since alertMsg is a component state value, the function that uses it must be defined inside the component function; otherwise, it won‚Äôt have access to that state value.

#### This can all sound quite confusing, but it comes down to two simple rules:
- Always add all non-external dependencies‚Äîno matter whether they‚Äôre variables or functions.
- Functions are just objects and can change if their surrounding code executes again.

### Avoiding Unnecessary Effect Executions
Since all dependencies should be added to useEffect(), you sometimes end up with code that causes an effect to execute unnecessarily.

Consider the example component below:

üìì Note

The complete example can be found on GitHub at https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/unnecessary-executions.

```
import { useState, useEffect } from 'react';
function Alert() {
  const [enteredEmail, setEnteredEmail] = useState('');
  const [enteredPassword, setEnteredPassword] = useState('');
  function handleUpdateEmail(event) {
    setEnteredEmail(event.target.value);
  }
  function handleUpdatePassword(event) {
    setEnteredPassword(event.target.value);
  }
  function validateEmail() {
    if (!enteredEmail.includes('@')) {
      console.log('Invalid email!');
    }
  }
  useEffect(function () {
    validateEmail();
  }, [validateEmail]);
  return (
    <form>
      <div>
        <label>Email</label>
        <input type="email" onChange={handleUpdateEmail} />
      </div>
      <div>
        <label>Password</label>
        <input type="password" onChange={handleUpdatePassword} />
      </div>
      <button>Save</button>
    </form>
  );
}
export default Alert;
```

This component contains a form with two inputs. The entered values are stored in two different state values (enteredEmail and enteredPassword). The validateEmail() function then performs some email validation and, if the email address is invalid, logs a message to the console. validateEmail() is executed with the help of useEffect().

The problem with this code is that the effect function will be executed whenever `validateEmail` changes because, correctly, `validateEmail` was added as a dependency. But `validateEmail` will change **whenever the component function is executed again**. And that‚Äôs not just the case for state changes to `enteredEmail` but also whenever `enteredPassword` changes‚Äîeven though that state value is not used at all inside of `validateEmail`.

This unnecessary effect execution can be avoided with various solutions:

- You could move the code inside of `validateEmail` directly into the effect function (`enteredEmail` would then be the only dependency of the effect, avoiding effect executions when any other state changes).
- You could avoid using `useEffect()` altogether since you could perform email validation inside of `handleUpdateEmail`. Having `console.log()` (a side effect) in there would be acceptable since it wouldn‚Äôt cause any harm.
- You could call `validateEmail()` directly in the component function‚Äîsince it doesn‚Äôt change any state, it wouldn‚Äôt trigger an infinite loop.

üìì Note

There is an article in the official React documentation that highlights scenarios where you might not need useEffect(): https://react.dev/learn/you-might-not-need-an-effect.

In addition, I created a video that summarizes the most important situations in which you do or do not need useEffect(): https://www.youtube.com/watch?v=V1f8MOQiHRw.


Of course, in some other scenarios, you might need to use `useEffect()`. Fortunately, React also offers a solution for situations like this: you can wrap the function that‚Äôs used as a dependency with another React Hook, the `useCallback()` Hook.

The adjusted code would look like this:
```
import { useState, useEffect, useCallback } from 'react';
function Alert() {
  const [enteredEmail, setEnteredEmail] = useState('');
  const [enteredPassword, setEnteredPassword] = useState('');
  function handleUpdateEmail(event) {
    setEnteredEmail(event.target.value);
  }
  function handleUpdatePassword(event) {
    setEnteredPassword(event.target.value);
  }
  const validateEmail = useCallback(
    function () {
      if (!enteredEmail.includes('@')) {
        console.log('Invalid email!');
      }
    },
    [enteredEmail]
  );
  useEffect(
    function() {
      validateEmail();
    },
    [validateEmail]
  );
  // return JSX code ...
}
export default Alert;
```

`useCallback()`, like all React Hooks, is a function that‚Äôs executed directly inside the component function. Like `useEffect()`, it accepts two arguments: another function (which can be anonymous or a named function) and a dependencies array.

Unlike `useEffect()`, though, `useCallback()` does not execute the received function. Instead, `useCallback()` **ensures that a function is only recreated if one of the specified dependencies has changed**. The default JavaScript behavior of creating a new function object whenever the surrounding code executes again is (synthetically) disabled.

`useCallback()` **returns the latest saved function object**. Hence, that returned value (which is a function) is saved in a variable or constant (`validateEmail` in the previous example).

Since the function wrapped by `useCallback()` now only changes when one of the dependencies changes, the returned function can be used as a dependency for `useEffect()` without executing that effect for all kinds of state changes or component updates.

In the case of the preceding example, the effect function would then only execute when `enteredEmail` changes‚Äîbecause that‚Äôs the only change that will lead to a new `validateEmail` function object being created.

Another common reason for unnecessary effect execution is the usage of objects as dependencies, like in this example:
```
import { useEffect } from 'react';
function Error(props) {
  useEffect(
    function () {
      // performing some error logging
      // in a real app, a HTTP request might be sent to some analytics API
      console.log('An error occurred!');
      console.log(props.message);
    },
    [props]
  );
  return <p>{props.message}</p>;
}
export default Error;
```

This Error component is used in another component, the Form component, like this:
```
import { useState } from 'react';
import Error from './Error.jsx';
function Form() {
  const [enteredEmail, setEnteredEmail] = useState('');
  const [errorMessage, setErrorMessage] = useState('');
  function handleUpdateEmail(event) {
    setEnteredEmail(event.target.value);
  }
  function handleSubmitForm(event) {
    event.preventDefault();
    if (!enteredEmail.endsWith('.com')) {
      setErrorMessage('Only email addresses ending with .com are accepted!');
    }
  }
  return (
    <form onSubmit={handleSubmitForm}>
      <div>
        <label>Email</label>
        <input type="email" onChange={handleUpdateEmail} />
      </div>
      {errorMessage && <Error message={errorMessage} />}
      <button>Submit</button>
    </form>
  );
}
export default Form;
```

The Error component receives an error message via props (props.message) and displays it on the screen. In addition, with the help of useEffect(), it does some error logging. In this example, the error is simply output to the JavaScript console. In a real app, the error might be sent to some analytics API via an HTTP request. Either way, a side effect that depends on the error message is performed.

The Form component contains two state values, tracking the entered email address as well as the error status of the input. If an invalid input value is submitted, errorMessage is set and the Error component is displayed.

The interesting part about this example is the dependency array of useEffect() inside the Error component. It contains the props object as a dependency (props is always an object, grouping all prop values together). When using objects (props or any other object; it does not matter) as dependencies for useEffect(), unnecessary effect function executions can be the result.

You can see this problem in this example. If you run the app and enter an invalid email address (e.g., test@test.de), you‚Äôll notice that subsequent keystrokes in the email input field will cause the error message to be logged (via the effect function) for every keystroke.

üìì Note

The full code can be found on GitHub at https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/08-effects/examples/objects-as-dependencies.


<img width="877" height="448" alt="image" src="https://github.com/user-attachments/assets/e66f33a5-40f6-42b2-9f0e-ff72c0f88fee" />

Those extra executions can occur because component re-evaluations (i.e., component functions being invoked again by React) will produce brand-new JavaScript objects. Even if the values of properties of those objects did not change (as in the preceding example), technically, a brand-new object in memory is created by JavaScript. Since the effect depends on the entire object, React only ‚Äúsees‚Äù that there is a new version of that object and hence runs the effect again.

In the preceding example, a new props object (for the Error component) is created whenever the Form component function is called by React‚Äîeven if the error message (the only prop value that‚Äôs set) did not change.

In this example, that‚Äôs just annoying since it clutters the JavaScript console in the developer tools. However, if you were sending an HTTP request to some analytics backend API, it could cause bandwidth problems and make the app slower. Therefore, it‚Äôs best if you get into the habit of avoiding unnecessary effect executions as a general rule.

In the case of object dependencies, the best way to avoid unnecessary executions is to simply destructure the object so that you can pass only those object properties as dependencies that are needed by the effect:
```
function Error(props) {
  const { message } = props; // destructure to extract required properties
  useEffect(
    function () {
      console.log('An error occurred!');
      console.log(message);
    },
    // [props] // don't use the entire props object!
    [message]
  );
  return <p>{message}</p>;
}
```

Using this approach, you ensure that only the required property values are set as dependencies. Therefore, even if the object gets recreated, the property value (in this case, the value of the message property) is the only thing that matters. If it doesn‚Äôt change, the effect function won‚Äôt be executed again.

### Effects and Asynchronous Code
Some effects deal with asynchronous code (sending HTTP requests is a typical example). When performing asynchronous tasks in effect functions, there is one important rule to keep in mind, though: the effect function itself should not be asynchronous and should not return a promise. This does not mean that you can‚Äôt work with promises in effects‚Äîyou just must not return a promise.

You might want to use async/await to simplify asynchronous code, but when doing so inside of an effect function, it‚Äôs easy to accidentally return a promise. For example, the following code **would work but does not follow best practices**:

```
useEffect(async function () {
  const fetchedPosts = await fetchPosts();
  setLoadedPosts(fetchedPosts);
}, []);
```

Adding the async keyword in front of function unlocks the usage of await inside the function‚Äîwhich makes dealing with asynchronous code (that is, with promises) more convenient.

But the effect function passed to useEffect() should only return a normal function, if anything. It should not return a promise. Indeed, React actually issues a warning when trying to run code like the preceding snippet:

<img width="477" height="227" alt="image" src="https://github.com/user-attachments/assets/ca232e6e-9dcb-4b4d-b03a-bf9f35fb435f" />

To avoid this warning, you can use promises without async/await, like this:
```
useEffect(function () {
  fetchPosts().then((fetchedPosts) => setLoadedPosts(fetchedPosts));
}, []);
```

This works because the effect function doesn‚Äôt return the promise.

Alternatively, if you want to use async/await, you can create a separate wrapper function inside of the effect function, which is then executed in the effect:
```
useEffect(function () {
  async function loadData() {
    const fetchedPosts = await fetchPosts();
    setLoadedPosts(fetchedPosts);
  }
 
  loadData();
}, []);
```

By doing that, the **effect function itself is not asynchronous** (it does not return a promise), but you can still use `async/await`.

### Rules of Hooks
In this chapter, two new Hooks were introduced: useEffect() and useCallback(). Both Hooks are very important‚ÄîuseEffect() especially, as this is a Hook you will typically use a lot. Together with useState() (introduced in Chapter 4, Working with Events and State) and useRef() (introduced in Chapter 7, Portals and Refs), you now have a solid set of key React Hooks.

#### When working with React Hooks, there are two rules (the so-called rules of Hooks) you must follow:

- Only call Hooks at the top level of component functions. Don‚Äôt call them inside of if statements, loops, or nested functions.
- Only call Hooks inside of React components or custom Hooks (custom Hooks will be covered in Chapter 12, Building Custom React Hooks).

### Summary and Key Takeaways
- Actions that **are not directly related to the main process of a function** can be considered **side effects**.
- Side effects can be **asynchronous** tasks (for example, sending an HTTP request), but can also be **synchronous** (for example, console.log() or accessing browser storage).
- Side effects are often needed to achieve a certain goal, but it‚Äôs a good idea **to separate them from the main process of a function**.
- Side effects can become problematic if they cause infinite loops (because of the update cycles between effect and state).
- `useEffect()` is a React Hook that should be used **to wrap side effects** and perform them in a safe way.
- `useEffect()` takes an **effect function** and an **array of effect dependencies**.
- The effect function **is executed directly after the component function is invoked** (not simultaneously).
- Any value, variable, or function **used inside of an effect** should be added **to the dependencies array**.
- Dependency array exceptions are external values (defined outside of a component function), state updating functions, or values defined and used inside of the effect function.
- If **no dependency array** is specified, the effect function executes **after every component function invocation**.
- If an **empty dependency array** is specified, the effect function **runs once when the component first mounts** (that is, when it is created for the first time).
- Effect functions can also return optional cleanup functions that **are called right before an effect function is executed again** (and right before a component is removed from the DOM).
- Effect functions **must not** return promises.
- For function dependencies, `useCallback()` can help reduce the number of effect executions.
- For object dependencies, destructuring can help reduce the number of effect executions.

















