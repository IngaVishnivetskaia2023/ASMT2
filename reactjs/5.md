## Server-side Rendering & Building Fullstack Apps with Next.js

#### Learning Objectives

By the end of this chapter, you will be able to do the following:

- Describe the difference between client-side and server-side React
- Determine which kind of React app to build
- Build fullstack React apps with the help of the Next.js framework
- Explain the key features and advantages of Next.js

### Introduction
Thus far in this book, you have learned a lot about building client-side React applications, that is, applications where the (transpiled) React code executes in the browsers of your website visitors.

This makes sense because React was originally created to simplify the process of building interactive and reactive UIs by running JavaScript code on the client side. 
To this date, most React features, including the ones covered up to this point in this book (e.g., state, context, and routing), exist to fulfill this purpose.

But, as you will learn in this and the following chapters, you can actually also **execute React code on the server side**. 
There are certain React features that may only be used there—for example, **React Server Components**, which will be covered in great detail in the Chapter 16, React Server Components & Server Actions.

This chapter will get you started with React on the server side, briefly explain what **server-side rendering (SSR)** is, and introduce you to Next.js, a popular and feature-rich fullstack framework for React that allows you to blend backend and frontend code. 
You will learn how to create Next.js apps and how to use core Next.js features like file-based routing.

### What’s the Problem with Client-Side React Apps?
The big advantage of single-page applications (SPAs) and client-side React is that you can build highly reactive and interactive web UIs. The UI can be updated almost instantly, visible page reloads and switches can be avoided, and hence your users benefit from a mobile-app-like user experience.

But this reliance on client-side code (and, therefore, JavaScript) also has potential disadvantages:

- If users disable JavaScript, the website will be pretty much unusable.
- The **initially fetched HTML document is almost empty** — data fetching and content rendering only take place **after that initial HTTP request and response**.


The first point might not matter too much, since only a small subset of all users will disable JavaScript and you can show an appropriate warning message via the `<noscript>` tag.

But the second point can have significant consequences. Since the initial HTML document is almost empty, users won’t see any content until all the JavaScript code has been fetched and executed. While most users might not see a notable delay, depending on the device and internet connection of a user, this may take up to a few seconds for some users.

In addition, search engine crawlers (e.g., Google’s crawler) will not necessarily wait for all your client-side JavaScript code to be fetched and executed when indexing your page. Therefore, those crawlers may see a mostly empty page and hence rank your website badly (or not index it at all).

<img width="877" height="311" alt="image" src="https://github.com/user-attachments/assets/e08fd8a1-07a3-4c99-81f6-85766ff7dca0" />

Figure 15.1 shows the page source code (which can be inspected by right-clicking on the website) of a typical React app. As you can see in that figure, there’s almost no content between the <body> tags. The title ("Hello World!") and the text below it are missing in that source code. The content is missing there because it’s not part of the initial HTTP response. Instead, it’s rendered by the transpiled React code after the page loaded (and after that code was downloaded from the server).

Of course, these disadvantages won’t matter in all cases. If you’re building some company-internal application, or a UI that’s hidden behind some login (and hence won’t be indexed anyway), or if you’re only targeting users with fast devices and internet connections, you might not need to worry about these potential problems.

But if you’re building **a public-facing website where search engine indexing matters** or that may be visited by users with slow devices or internet connections, you might want to consider getting rid of these disadvantages. And that’s precisely **where SSR can help out**.

### Making Sense of Server-side Rendering (SSR)
When working with React, **SSR refers to the process of rendering web pages**, and therefore your React components, on the server that handles the incoming HTTP request when a user visits your website.

With SSR enabled, **the server will render your React component tree and hence produce the actual HTML code yielded by your components and their JSX instructions**. It’s **this finished HTML code that’s then sent back to the client**. As a result, website visitors will receive an HTML file that’s not empty anymore but that instead contains the actual page content. Search engine crawlers will also see that content and index the page accordingly.

<img width="666" height="456" alt="image" src="https://github.com/user-attachments/assets/098bee97-5f2e-4a5d-9c0b-ec798d2f1641" />

Best of all, you don’t lose the client-side advantages of React because, when enabling SSR, React still works on the client side as it did before! It’ll take over control once that initial HTML document has been received and provide users with the same SPA experience you were able to deliver without SSR. Though, **technically, when using SSR, React will be initialized slightly differently on the client. Instead of re-rendering the entire DOM there, it’ll hydrate the page content that was rendered on the server. Hydration means that React will connect your component structure to the rendered HTML code (which was rendered based on that same structure, of course) and make it interactive**.

<img width="658" height="440" alt="image" src="https://github.com/user-attachments/assets/b0aae3ab-b37d-4ba3-8c88-eeb501883659" />

#### SSR (Server-Side Rendering):
сервер рендерит React-компоненты в HTML и отдаёт готовую страницу пользователю, поэтому он видит содержимое быстрее.

#### Гидрация (hydration):
когда браузер загружает JS-приложение, React «подключает» свою структуру к уже отрендеренному сервером HTML, навешивает обработчики событий и делает страницу интерактивной, не перерисовывая её целиком.

#### Пошаговый разбор (детально):

<img width="854" height="866" alt="Снимок экрана (328)" src="https://github.com/user-attachments/assets/e9f8727b-ad3e-4498-b707-d0c438c8896f" />


1. Запрос пользователя — браузер делает HTTP `GET` к серверу (например, /).

2. Сервер рендерит React — на сервере вызывается `renderToString` (или `renderToPipeableStream`), который превращает компонент `App` в HTML-строку. Сервер может подставить начальные данные (props) в компонент перед рендером.

3. Сервер отдаёт HTML — клиент получает готовую страницу: полностью сформированный DOM (в `<div id="root">...</div>` лежит HTML приложения).

4. Первичная отрисовка в браузере — пользователь сразу видит контент (лучший `UX`, `SEO` и стартовый `paint` быстрее).

5. Загрузка JavaScript — браузер загружает и парсит клиентский бандл (`client.js`). До этого интерактивность (клики, формы) не работает — это просто статический `HTML`.

6. Гидрация — в `client.js` вызывается `hydrateRoot(document.getElementById('root'), <App .../>)`. React сравнивает свою виртуальную структуру с существующим DOM и "присоединяется" к нему, навешивая обработчики событий, создавая внутренние структуры (`fibers`) и синхронизируя состояние.

7. SPA-поведение — после успешной гидрации приложение полностью интерактивно и работает как обычное одностраничное приложение (SPA).

#### Что именно делает гидрация (technical)

- React при гидрации не создаёт все DOM-узлы заново (в идеальном случае). Вместо этого он сопоставляет (reconcile) виртуальные элементы с уже существующим DOM, чтобы переиспользовать узлы.
- Гидрация навешивает обработчики событий, создает внутренние структуры React (fibers) и начинает отслеживать состояние компонентов.
- Если HTML, сгенерированный сервером, не совпадает с тем, что React ожидает при рендере на клиенте, будет предупреждение о mismatch, и React может выполнить исправление — перерендерить часть или весь DOM.

### Adding SSR to a React Application
It is extremely important to understand that SSR-enabled React applications need to execute code in two environments (server and browser), whereas client-side React applications only rely on the browser. Therefore, to use SSR, a server-side environment must be added to the React project—it’s not enough to just adjust the React code in a few places.

For example, standard Vite-based projects don’t support SSR out of the box. Consequently, if you want to support SSR, you must edit your Vite project setup (and some of your project code files) to enable executing React code on both the client and server side. For example, you must add some code that handles incoming HTTP requests and triggers React code execution on the server side.


#### Note

Manually enabling SSR requires backend development and build process configuration knowledge—in addition to the React knowledge you need.

Thankfully, though, as you’ll learn throughout this chapter, you often don’t need to go through that setup process. Instead, you can rely on frameworks like Next.js to do the heavy lifting for you.

If you’re interested in manually configuring SSR in Vite-based projects, the official Vite SSR documentation is a great place to learn more: https://vitejs.dev/guide/ssr.

In addition, you can explore the following demo project that was set up according to the official Vite SSR instructions: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled.


The fact that manually enabling SSR is a non-trivial process that requires advanced Node.js and backend development knowledge is one of the reasons why the official React documentation recommends creating new React projects with the help of frameworks like Next.js (see https://react.dev/learn/start-a-new-react-project).

But it’s not the only reason.

### Server-side Data Fetching Is Not Trivial

Besides the non-trivial setup process, SSR-enabled projects also suffer from another possible problem: server-side data fetching is difficult.

If you’re building a React app that needs to fetch data in some components (e.g., with the help of useEffect(), as shown in Chapter 8, Handling Side Effects), you’ll find out that the data is not fetched when the component is rendered on the server. Instead, the data fetching will only occur on the client side. The server-side rendered HTML markup will not contain the content that depends on the fetched data.

The reason for this behavior is that React component functions are only executed on the server once—i.e., it’s only the first component render cycle that’s performed on the server. You can think of SSR producing only an initial page snapshot. Subsequent state updates are ignored, and effect functions (triggered via useEffect()) are also therefore not executed on the server side. As a result, data fetching that relies on effect functions and subsequent state updates will not work on the server side.

Consider this example, where a Todos component function uses useEffect() to fetch some (dummy) to-dos data from https://jsonplaceholder.typicode.com/:

```
import { useEffect, useState } from 'react';
import { loadTodos, saveTodo } from '../todos.js';
function Todos() {
  const [todos, setTodos] = useState();
  useEffect(() => {
    async function fetchTodos() {
      // sends HTTP request to jsonplaceholder.typicode.com
      const todos = await loadTodos();
      setTodos(todos);
    }
    fetchTodos();
  }, []);
  async function addTodoAction(fd) {
    const todo = {
      title: fd.get('title'),
    };
    const savedTodo = await saveTodo(todo);
    setTodos((prevTodos) => [savedTodo, ...prevTodos]);
  }
  return (
    <section>
      <h2>Manage your todos</h2>
      <form action={addTodoAction}>
        <input type="text" name="title" />
        <button type="submit">Add Todo</button>
      </form>
      {(!todos || todos.length === 0) && (
        <p>No todos found.</p>
      )}
      {todos && todos.length > 0 && (
        <ul>
          {todos.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )}
    </section>
  );
}
```

#### Note
You find the complete example code on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching.

When running this code on the server, there won’t be any errors. Instead, the app will run as expected and fetch the dummy to-dos from the backend server.

However, the HTML document that’s produced on the server will not contain the fetched to-dos. Instead, it will just contain the fallback text ("No todos found").

The generated markup does not contain the fetched to-dos because, as explained above, React component functions only execute once on the server side (and the function passed to useEffect() doesn’t execute at all).

Due to this behavior, you can’t easily perform asynchronous operations and, for example, fetch data via useEffect() in your React components when using SSR. Hence, the server-side rendered HTML content will never contain that data.

While you can come up with workarounds to that problem (e.g., perform the data fetching operation on the server, before executing the component functions) that’s a problem that will be solved by Next.js and a concept called `React Server Components (RSC)`.


#### Почему useEffect не выполняется на сервере:

- При SSR React рендерит компоненты только один раз на сервере — это первый рендер.

- На сервере нет полноценного жизненного цикла React-компонента: отсутствует фаза `commit`, в которой запускаются эффекты.

- `useEffect` всегда планируется **после монтирования компонента**, но на сервере нет `DOM` и нет понятия "монтирования" в браузерный интерфейс, поэтому React просто игнорирует этот код.

- Это не ошибка — React сознательно не выполняет эффекты на сервере, так как они часто зависят от браузерных API (window, document, события и т.п.).

- В результате код в `useEffect` (например, запросы к API) будет выполнен только на клиенте, уже после гидрации.

- Поэтому HTML, который отдаёт сервер, содержит только "пустое" или fallback-состояние (например, "No todos found").


### Introducing Next.js
Next.js is a React framework—i.e., a framework that builds upon React and adds extra features and patterns to it. Specifically, Next.js adds features like file-based routing, built-in SSR, or automatic caching to improve performance. Though, most importantly, it unlocks two crucial React concepts: **React Server Components (RSC)** and **Server Actions**. As you will learn, these features enable server-side React code to perform asynchronous operations and, for example, fetch and render data on the server.

Thus, Next.js saves you the effort of manually enabling SSR, and, additionally, unlocks other powerful features that help with fetching data on the server.

#### Note

There are also alternative React frameworks like Remix/React Router (they were merged to bring optional fullstack React framework features to React Router) or TanStack Start.

Next.js has not only existed for a very long time but it’s also the most popular (measured by usage) fullstack framework at the point in time when this book was written.


### Creating Next.js Projects
To use Next.js, you must first create a Next.js project. Technically, **it’ll still be a React project**, which means you will be able to use React features like components, props, state, Hooks, or JSX. **But it’ll be a project that comes with the next package installed**, and that enforces a certain folder structure that’s needed by Next.js. **You can’t install Next.js into an existing (Vite-based) React project** and start using it there. Significant adjustments to the project configuration and structure would be required. Next.js brings its own build process and does not use Vite under the hood. Hence, creating a brand-new project makes more sense.

To get started with a new Next.js project, you should run the following command in your system terminal or command prompt (in a place on your system where you want the new project folder to be created):
```
npx create-next-app@latest first-next-app
```

After running this command, you’ll have to make a couple of choices in the terminal (e.g., if you want to use TypeScript).

You can confirm all those choices by simply pressing the Enter key, hence accepting the default option. However, you should ensure that you choose No for TypeScript (unless you know how to use it) and Yes for App Router. You can find a (slightly cleaned up) starting project on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro.

Inside the created project folder, a development server can be started via:
```
npm run dev
```

Just as in a Vite-based project, you should keep this process up and running while you’re working on the project code. The underlying build process will automatically reload and update the preview website as you make changes to your code.

#### Note

Next.js is an established, mature framework that’s never stopped innovating and changing.

In late 2022, the so-called App Router was introduced as a new way of structuring and building Next.js applications (the old approach is now referred to as Pages Router). This book, of course, covers the new App Router approach.

As of mid-2024 (when this edition is written), the App Router approach, despite being marked as stable, still frequently receives new features and changes.

Therefore, even though unlikely, the concepts and code explained in this book may change or break over time. The setup process described above may change, too. In such cases, a note (with instructions on how to adjust the code) will be added to the Changelog document on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md.
While the command is the same as in a Vite project, the server will actually target a different port by default. Instead of localhost:5173 (Vite), Next.js projects use localhost:3000 for the preview development server.

A newly created Next.js project comes with all its dependencies installed (npm install is automatically executed as part of the project creation process) and a project structure like this:

- An app/ folder that holds route-related files (see the next section)
- A public/ folder that can be used to store assets that should be served statically (i.e., without being changed by the build process)
- jsconfig.json and nextjs.config.mjs files for configuring the project and Next.js-specific behaviors
- package.json and package-lock.json for managing project dependencies

Hence, except for the app/ folder, it’s not too different from the structure you know from Vite. However, it is worth noting that Next.js, unlike Vite, does not enforce .jsx as a file extension for JavaScript files that contain JSX code. You can use it but you don’t have to. For example, the starting project uses page.js and layout.js, not page.jsx and layout.jsx, even though these files contain JSX code.

Just like Vite-based projects, Next.js projects come with a build workflow that processes and transpiles your code files automatically, when running the development server or building for production (which you can do via npm run build).

Like pretty much all modern React project setups, Next.js projects therefore support importing style files (like globals.css) or images into JavaScript files. It also allows you to omit or set file extensions on imports. In addition, Next.js has CSS Modules support, too.

Put in other words: you can work in Next.js projects in pretty much the same way as you do in Vite-based projects.

### Working with File-Based Routes
In Vite-based projects, you have a high degree of flexibility when it comes to the project structure. Inside the src/ folder, you can create any subfolders and files of your choice. The names of those files and folders also don’t really matter (if they’re valid and use the right extensions).

When working with React Router, you would set up routes in one of your JSX code files and load any component stored in any file for any route (see Chapter 13, Multipage Apps with React Router).

In Next.js projects, that’s a bit different because Next.js uses the file system for defining routes—you don’t set up routes in code. As a result, while you still have lots of flexibility, there are some routing-related rules regarding the project structure and file names that must be followed—otherwise, the app will break and not work as intended.

**Next.js implements file-based routing via its own built-in router. This router analyzes your file system and derives supported routes, their URL paths, and which React components to load and render based on the file and folder structure in your project.**

When using the App Router approach, you therefore must store all components that should be loaded as pages inside the app/ folder (or a nested folder) in files named page.js. Since all route component files must be named page.js, it’s the parent folder names that define the route path for which the component will get loaded.

For example, you might have a file and folder structure as shown in Figure 15.5:

<img width="623" height="461" alt="image" src="https://github.com/user-attachments/assets/c1999566-56db-4ea3-957a-b2d9a405de21" />

In Figure 15.5, you can see that four routes are defined via the file system: a root route (/) and the /about, /users, and /terms/en routes. For each route, the component stored in the respective page.js will be loaded and rendered onto the screen.

For example, you might have an app/page.js file like this:
```
export default function Home() {
  return (
    <main>
      <h1>Hello Next.js World </h1>
      <p>Build fullstack React applications with ease!</p>
      <p>
        Learn more about Next.js in{' '}
        <a href="https://www.udemy.com/course/nextjs-react-the-complete-guide/">
          my course
        </a>{' '}
        or the <a href="https://nextjs.org/">official documentation</a>.
      </p>
    </main>
  );
}
```

As you can see, a regular React component function is stored in this page.js file. The name of the component function does not matter—it’s just important that it’s a component function that’s exported inside a file named page.js. As a result, the following content will be visible on the screen if a user visits <domain>/ (or just <domain>, without the forward slash).

You can therefore easily add as many, possibly nested, routes as needed—simply by creating folders, subfolders, and page.js files.

### Server-side Rendering with Next.js
Besides providing a built-in file-based router (and many other features that will be explored throughout this and the next chapters), Next.js has one other crucial advantage: **it implements SSR out of the box**. You don’t have to add any files, change any configuration, or adjust any code to render React components on the server—instead, it works right from the start.

Consequently, the app/page.js file component (the Home component in the example above), **is evaluated and rendered on the server side when a user visits <domain>/**. **It’s the finished HTML code that’s sent to the browser**. And, just as with Vite-based projects with custom SSR, Next.js renders all child components that may be used inside of page.js on the server, too.

In addition, when building websites with Next.js, you still build React apps. That’s why Next.js apps become interactive on the client side once the SSR is done. **Technically, as you’ll also learn in the next chapter (React Server Components & Server Actions), they’ll be made interactive in a different way than in Vite-based SSR-enabled React apps (where React hydrates the server-side rendered markup on the client)**, but ultimately, your website users will have a SPA-like user experience.

Therefore, if you want to build a React app that supports SSR, relying on a framework like Next.js instead of setting up SSR manually is recommended.

In addition, you will be able to use other helpful features, like the file-based routing system, especially since it doesn’t stop at defining routes via page.js files. It, for example, also simplifies the process of defining layouts.

### Working with Layouts
As mentioned, when it comes to routing, file names and where you store those files matter.

For example, you’ll also find a layout.js file next to the page.js file in the app/ folder from the example above.

<img width="240" height="534" alt="image" src="https://github.com/user-attachments/assets/7bcaef22-fd69-4527-92d1-020421e158aa" />

**Just like `page.js`, `layout.js` is a reserved file name—i.e., that file is handled by Next.js in a special way.**

This `layout.js` file also exports a component function, but the created component will not be rendered for one specific path. Instead, **it is used as a wrapper around all sibling or nested pages. Thus, the `layout.js` file can be used to define JSX code that will be shared across multiple pages.**

Since it’s meant to be used as a wrapper component, the component function exported by layout.js must use the special children prop (see Chapter 3, Components & Props) to define the place where the wrapped page content should be displayed.

For example, you could use the `app/layout.js` file to define a global layout that adds a navigation bar above the `<main>` content:

```
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>
          <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/events">Events</a></li>
            </ul>
          </nav>
        </header>
        <main>{children}</main>
      </body>
    </html>
  );
}
```

In this example code snippet, it’s also worth noting that the `RootLayout` component renders the `<html>` and `<body>` elements. In Vite-based projects, that’s not something you would do. There, you instead define a place in the `index.html` file where the rendered HTML should be injected (via the `createRoot()` function exposed by the react-dom package; see Chapter 2, Understanding React Components & JSX).

Next.js **does not rely** on such an `index.html` file; instead, **it forces you to define a root `layout.js` file at the top level** of the `app/` folder. It’s then this root layout that must define the general structure of the rendered HTML page. However, **there is no `<head>` section in that file, since Next.js will manage and inject that section behind the scenes**. In addition, Next.js will **also insert JavaScript and CSS imports** into the rendered HTML document.

You may add more (nested) layout.js files if you want to have nested layouts that only wrap some of your pages. Such layouts are optional; the root layout (`app/layout.js`) **is mandatory**, however.

With a `layout.js` file like the one shown in the previous code example, in a project that contains an `app/page.js` file, and an `app/events/page.js` file, website users could visit both pages and see a shared navigation.



