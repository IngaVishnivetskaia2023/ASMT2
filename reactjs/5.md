## Server-side Rendering & Building Fullstack Apps with Next.js

#### Learning Objectives

By the end of this chapter, you will be able to do the following:

- Describe the difference between client-side and server-side React
- Determine which kind of React app to build
- Build fullstack React apps with the help of the Next.js framework
- Explain the key features and advantages of Next.js

### Introduction
Thus far in this book, you have learned a lot about building client-side React applications, that is, applications where the (transpiled) React code executes in the browsers of your website visitors.

This makes sense because React was originally created to simplify the process of building interactive and reactive UIs by running JavaScript code on the client side. 
To this date, most React features, including the ones covered up to this point in this book (e.g., state, context, and routing), exist to fulfill this purpose.

But, as you will learn in this and the following chapters, you can actually also **execute React code on the server side**. 
There are certain React features that may only be used there—for example, **React Server Components**, which will be covered in great detail in the Chapter 16, React Server Components & Server Actions.

This chapter will get you started with React on the server side, briefly explain what **server-side rendering (SSR)** is, and introduce you to Next.js, a popular and feature-rich fullstack framework for React that allows you to blend backend and frontend code. 
You will learn how to create Next.js apps and how to use core Next.js features like file-based routing.

### What’s the Problem with Client-Side React Apps?
The big advantage of single-page applications (SPAs) and client-side React is that you can build highly reactive and interactive web UIs. The UI can be updated almost instantly, visible page reloads and switches can be avoided, and hence your users benefit from a mobile-app-like user experience.

But this reliance on client-side code (and, therefore, JavaScript) also has potential disadvantages:

- If users disable JavaScript, the website will be pretty much unusable.
- The **initially fetched HTML document is almost empty** — data fetching and content rendering only take place **after that initial HTTP request and response**.


The first point might not matter too much, since only a small subset of all users will disable JavaScript and you can show an appropriate warning message via the `<noscript>` tag.

But the second point can have significant consequences. Since the initial HTML document is almost empty, users won’t see any content until all the JavaScript code has been fetched and executed. While most users might not see a notable delay, depending on the device and internet connection of a user, this may take up to a few seconds for some users.

In addition, search engine crawlers (e.g., Google’s crawler) will not necessarily wait for all your client-side JavaScript code to be fetched and executed when indexing your page. Therefore, those crawlers may see a mostly empty page and hence rank your website badly (or not index it at all).

<img width="877" height="311" alt="image" src="https://github.com/user-attachments/assets/e08fd8a1-07a3-4c99-81f6-85766ff7dca0" />

Figure 15.1 shows the page source code (which can be inspected by right-clicking on the website) of a typical React app. As you can see in that figure, there’s almost no content between the <body> tags. The title ("Hello World!") and the text below it are missing in that source code. The content is missing there because it’s not part of the initial HTTP response. Instead, it’s rendered by the transpiled React code after the page loaded (and after that code was downloaded from the server).

Of course, these disadvantages won’t matter in all cases. If you’re building some company-internal application, or a UI that’s hidden behind some login (and hence won’t be indexed anyway), or if you’re only targeting users with fast devices and internet connections, you might not need to worry about these potential problems.

But if you’re building **a public-facing website where search engine indexing matters** or that may be visited by users with slow devices or internet connections, you might want to consider getting rid of these disadvantages. And that’s precisely **where SSR can help out**.

### Making Sense of Server-side Rendering (SSR)
When working with React, **SSR refers to the process of rendering web pages**, and therefore your React components, on the server that handles the incoming HTTP request when a user visits your website.

With SSR enabled, **the server will render your React component tree and hence produce the actual HTML code yielded by your components and their JSX instructions**. It’s **this finished HTML code that’s then sent back to the client**. As a result, website visitors will receive an HTML file that’s not empty anymore but that instead contains the actual page content. Search engine crawlers will also see that content and index the page accordingly.

<img width="666" height="456" alt="image" src="https://github.com/user-attachments/assets/098bee97-5f2e-4a5d-9c0b-ec798d2f1641" />

Best of all, you don’t lose the client-side advantages of React because, when enabling SSR, React still works on the client side as it did before! It’ll take over control once that initial HTML document has been received and provide users with the same SPA experience you were able to deliver without SSR. Though, **technically, when using SSR, React will be initialized slightly differently on the client. Instead of re-rendering the entire DOM there, it’ll hydrate the page content that was rendered on the server. Hydration means that React will connect your component structure to the rendered HTML code (which was rendered based on that same structure, of course) and make it interactive**.

<img width="658" height="440" alt="image" src="https://github.com/user-attachments/assets/b0aae3ab-b37d-4ba3-8c88-eeb501883659" />

#### SSR (Server-Side Rendering):
сервер рендерит React-компоненты в HTML и отдаёт готовую страницу пользователю, поэтому он видит содержимое быстрее.

#### Гидрация (hydration):
когда браузер загружает JS-приложение, React «подключает» свою структуру к уже отрендеренному сервером HTML, навешивает обработчики событий и делает страницу интерактивной, не перерисовывая её целиком.

#### Пошаговый разбор (детально):

<img width="854" height="866" alt="Снимок экрана (328)" src="https://github.com/user-attachments/assets/e9f8727b-ad3e-4498-b707-d0c438c8896f" />


1. Запрос пользователя — браузер делает HTTP `GET` к серверу (например, /).

2. Сервер рендерит React — на сервере вызывается `renderToString` (или `renderToPipeableStream`), который превращает компонент `App` в HTML-строку. Сервер может подставить начальные данные (props) в компонент перед рендером.

3. Сервер отдаёт HTML — клиент получает готовую страницу: полностью сформированный DOM (в `<div id="root">...</div>` лежит HTML приложения).

4. Первичная отрисовка в браузере — пользователь сразу видит контент (лучший `UX`, `SEO` и стартовый `paint` быстрее).

5. Загрузка JavaScript — браузер загружает и парсит клиентский бандл (`client.js`). До этого интерактивность (клики, формы) не работает — это просто статический `HTML`.

6. Гидрация — в `client.js` вызывается `hydrateRoot(document.getElementById('root'), <App .../>)`. React сравнивает свою виртуальную структуру с существующим DOM и "присоединяется" к нему, навешивая обработчики событий, создавая внутренние структуры (`fibers`) и синхронизируя состояние.

7. SPA-поведение — после успешной гидрации приложение полностью интерактивно и работает как обычное одностраничное приложение (SPA).

#### Что именно делает гидрация (technical)

- React при гидрации не создаёт все DOM-узлы заново (в идеальном случае). Вместо этого он сопоставляет (reconcile) виртуальные элементы с уже существующим DOM, чтобы переиспользовать узлы.
- Гидрация навешивает обработчики событий, создает внутренние структуры React (fibers) и начинает отслеживать состояние компонентов.
- Если HTML, сгенерированный сервером, не совпадает с тем, что React ожидает при рендере на клиенте, будет предупреждение о mismatch, и React может выполнить исправление — перерендерить часть или весь DOM.

### Adding SSR to a React Application
It is extremely important to understand that SSR-enabled React applications need to execute code in two environments (server and browser), whereas client-side React applications only rely on the browser. Therefore, to use SSR, a server-side environment must be added to the React project—it’s not enough to just adjust the React code in a few places.

For example, standard Vite-based projects don’t support SSR out of the box. Consequently, if you want to support SSR, you must edit your Vite project setup (and some of your project code files) to enable executing React code on both the client and server side. For example, you must add some code that handles incoming HTTP requests and triggers React code execution on the server side.


#### Note

Manually enabling SSR requires backend development and build process configuration knowledge—in addition to the React knowledge you need.

Thankfully, though, as you’ll learn throughout this chapter, you often don’t need to go through that setup process. Instead, you can rely on frameworks like Next.js to do the heavy lifting for you.

If you’re interested in manually configuring SSR in Vite-based projects, the official Vite SSR documentation is a great place to learn more: https://vitejs.dev/guide/ssr.

In addition, you can explore the following demo project that was set up according to the official Vite SSR instructions: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled.


The fact that manually enabling SSR is a non-trivial process that requires advanced Node.js and backend development knowledge is one of the reasons why the official React documentation recommends creating new React projects with the help of frameworks like Next.js (see https://react.dev/learn/start-a-new-react-project).

But it’s not the only reason.

### Server-side Data Fetching Is Not Trivial

Besides the non-trivial setup process, SSR-enabled projects also suffer from another possible problem: server-side data fetching is difficult.

If you’re building a React app that needs to fetch data in some components (e.g., with the help of useEffect(), as shown in Chapter 8, Handling Side Effects), you’ll find out that the data is not fetched when the component is rendered on the server. Instead, the data fetching will only occur on the client side. The server-side rendered HTML markup will not contain the content that depends on the fetched data.

The reason for this behavior is that React component functions are only executed on the server once—i.e., it’s only the first component render cycle that’s performed on the server. You can think of SSR producing only an initial page snapshot. Subsequent state updates are ignored, and effect functions (triggered via useEffect()) are also therefore not executed on the server side. As a result, data fetching that relies on effect functions and subsequent state updates will not work on the server side.

Consider this example, where a Todos component function uses useEffect() to fetch some (dummy) to-dos data from https://jsonplaceholder.typicode.com/:

```
import { useEffect, useState } from 'react';
import { loadTodos, saveTodo } from '../todos.js';
function Todos() {
  const [todos, setTodos] = useState();
  useEffect(() => {
    async function fetchTodos() {
      // sends HTTP request to jsonplaceholder.typicode.com
      const todos = await loadTodos();
      setTodos(todos);
    }
    fetchTodos();
  }, []);
  async function addTodoAction(fd) {
    const todo = {
      title: fd.get('title'),
    };
    const savedTodo = await saveTodo(todo);
    setTodos((prevTodos) => [savedTodo, ...prevTodos]);
  }
  return (
    <section>
      <h2>Manage your todos</h2>
      <form action={addTodoAction}>
        <input type="text" name="title" />
        <button type="submit">Add Todo</button>
      </form>
      {(!todos || todos.length === 0) && (
        <p>No todos found.</p>
      )}
      {todos && todos.length > 0 && (
        <ul>
          {todos.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )}
    </section>
  );
}
```

#### Note
You find the complete example code on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching.

When running this code on the server, there won’t be any errors. Instead, the app will run as expected and fetch the dummy to-dos from the backend server.

However, the HTML document that’s produced on the server will not contain the fetched to-dos. Instead, it will just contain the fallback text ("No todos found").

The generated markup does not contain the fetched to-dos because, as explained above, React component functions only execute once on the server side (and the function passed to useEffect() doesn’t execute at all).

Due to this behavior, you can’t easily perform asynchronous operations and, for example, fetch data via useEffect() in your React components when using SSR. Hence, the server-side rendered HTML content will never contain that data.

While you can come up with workarounds to that problem (e.g., perform the data fetching operation on the server, before executing the component functions) that’s a problem that will be solved by Next.js and a concept called `React Server Components (RSC)`.


#### Почему useEffect не выполняется на сервере:

- При SSR React рендерит компоненты только один раз на сервере — это первый рендер.

- На сервере нет полноценного жизненного цикла React-компонента: отсутствует фаза `commit`, в которой запускаются эффекты.

- `useEffect` всегда планируется **после монтирования компонента**, но на сервере нет `DOM` и нет понятия "монтирования" в браузерный интерфейс, поэтому React просто игнорирует этот код.

- Это не ошибка — React сознательно не выполняет эффекты на сервере, так как они часто зависят от браузерных API (window, document, события и т.п.).

- В результате код в `useEffect` (например, запросы к API) будет выполнен только на клиенте, уже после гидрации.

- Поэтому HTML, который отдаёт сервер, содержит только "пустое" или fallback-состояние (например, "No todos found").


### Introducing Next.js
Next.js is a React framework—i.e., a framework that builds upon React and adds extra features and patterns to it. Specifically, Next.js adds features like file-based routing, built-in SSR, or automatic caching to improve performance. Though, most importantly, it unlocks two crucial React concepts: **React Server Components (RSC)** and **Server Actions**. As you will learn, these features enable server-side React code to perform asynchronous operations and, for example, fetch and render data on the server.

Thus, Next.js saves you the effort of manually enabling SSR, and, additionally, unlocks other powerful features that help with fetching data on the server.

#### Note

There are also alternative React frameworks like Remix/React Router (they were merged to bring optional fullstack React framework features to React Router) or TanStack Start.

Next.js has not only existed for a very long time but it’s also the most popular (measured by usage) fullstack framework at the point in time when this book was written.


### Creating Next.js Projects
To use Next.js, you must first create a Next.js project. Technically, **it’ll still be a React project**, which means you will be able to use React features like components, props, state, Hooks, or JSX. **But it’ll be a project that comes with the next package installed**, and that enforces a certain folder structure that’s needed by Next.js. **You can’t install Next.js into an existing (Vite-based) React project** and start using it there. Significant adjustments to the project configuration and structure would be required. Next.js brings its own build process and does not use Vite under the hood. Hence, creating a brand-new project makes more sense.

To get started with a new Next.js project, you should run the following command in your system terminal or command prompt (in a place on your system where you want the new project folder to be created):
```
npx create-next-app@latest first-next-app
```

After running this command, you’ll have to make a couple of choices in the terminal (e.g., if you want to use TypeScript).

You can confirm all those choices by simply pressing the Enter key, hence accepting the default option. However, you should ensure that you choose No for TypeScript (unless you know how to use it) and Yes for App Router. You can find a (slightly cleaned up) starting project on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/04-nextjs-intro.

Inside the created project folder, a development server can be started via:
```
npm run dev
```

Just as in a Vite-based project, you should keep this process up and running while you’re working on the project code. The underlying build process will automatically reload and update the preview website as you make changes to your code.

#### Note

Next.js is an established, mature framework that’s never stopped innovating and changing.

In late 2022, the so-called App Router was introduced as a new way of structuring and building Next.js applications (the old approach is now referred to as Pages Router). This book, of course, covers the new App Router approach.

As of mid-2024 (when this edition is written), the App Router approach, despite being marked as stable, still frequently receives new features and changes.

Therefore, even though unlikely, the concepts and code explained in this book may change or break over time. The setup process described above may change, too. In such cases, a note (with instructions on how to adjust the code) will be added to the Changelog document on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md.
While the command is the same as in a Vite project, the server will actually target a different port by default. Instead of localhost:5173 (Vite), Next.js projects use localhost:3000 for the preview development server.

A newly created Next.js project comes with all its dependencies installed (npm install is automatically executed as part of the project creation process) and a project structure like this:

- An app/ folder that holds route-related files (see the next section)
- A public/ folder that can be used to store assets that should be served statically (i.e., without being changed by the build process)
- jsconfig.json and nextjs.config.mjs files for configuring the project and Next.js-specific behaviors
- package.json and package-lock.json for managing project dependencies

Hence, except for the app/ folder, it’s not too different from the structure you know from Vite. However, it is worth noting that Next.js, unlike Vite, does not enforce .jsx as a file extension for JavaScript files that contain JSX code. You can use it but you don’t have to. For example, the starting project uses page.js and layout.js, not page.jsx and layout.jsx, even though these files contain JSX code.

Just like Vite-based projects, Next.js projects come with a build workflow that processes and transpiles your code files automatically, when running the development server or building for production (which you can do via npm run build).

Like pretty much all modern React project setups, Next.js projects therefore support importing style files (like globals.css) or images into JavaScript files. It also allows you to omit or set file extensions on imports. In addition, Next.js has CSS Modules support, too.

Put in other words: you can work in Next.js projects in pretty much the same way as you do in Vite-based projects.

### Working with File-Based Routes
In Vite-based projects, you have a high degree of flexibility when it comes to the project structure. Inside the src/ folder, you can create any subfolders and files of your choice. The names of those files and folders also don’t really matter (if they’re valid and use the right extensions).

When working with React Router, you would set up routes in one of your JSX code files and load any component stored in any file for any route (see Chapter 13, Multipage Apps with React Router).

In Next.js projects, that’s a bit different because Next.js uses the file system for defining routes—you don’t set up routes in code. As a result, while you still have lots of flexibility, there are some routing-related rules regarding the project structure and file names that must be followed—otherwise, the app will break and not work as intended.

**Next.js implements file-based routing via its own built-in router. This router analyzes your file system and derives supported routes, their URL paths, and which React components to load and render based on the file and folder structure in your project.**

When using the App Router approach, you therefore must store all components that should be loaded as pages inside the app/ folder (or a nested folder) in files named page.js. Since all route component files must be named page.js, it’s the parent folder names that define the route path for which the component will get loaded.

For example, you might have a file and folder structure as shown in Figure 15.5:

<img width="623" height="461" alt="image" src="https://github.com/user-attachments/assets/c1999566-56db-4ea3-957a-b2d9a405de21" />

In Figure 15.5, you can see that four routes are defined via the file system: a root route (/) and the /about, /users, and /terms/en routes. For each route, the component stored in the respective page.js will be loaded and rendered onto the screen.

For example, you might have an app/page.js file like this:
```
export default function Home() {
  return (
    <main>
      <h1>Hello Next.js World </h1>
      <p>Build fullstack React applications with ease!</p>
      <p>
        Learn more about Next.js in{' '}
        <a href="https://www.udemy.com/course/nextjs-react-the-complete-guide/">
          my course
        </a>{' '}
        or the <a href="https://nextjs.org/">official documentation</a>.
      </p>
    </main>
  );
}
```

As you can see, a regular React component function is stored in this page.js file. The name of the component function does not matter—it’s just important that it’s a component function that’s exported inside a file named page.js. As a result, the following content will be visible on the screen if a user visits <domain>/ (or just <domain>, without the forward slash).

You can therefore easily add as many, possibly nested, routes as needed—simply by creating folders, subfolders, and page.js files.

### Server-side Rendering with Next.js
Besides providing a built-in file-based router (and many other features that will be explored throughout this and the next chapters), Next.js has one other crucial advantage: **it implements SSR out of the box**. You don’t have to add any files, change any configuration, or adjust any code to render React components on the server—instead, it works right from the start.

Consequently, the app/page.js file component (the Home component in the example above), **is evaluated and rendered on the server side when a user visits <domain>/**. **It’s the finished HTML code that’s sent to the browser**. And, just as with Vite-based projects with custom SSR, Next.js renders all child components that may be used inside of page.js on the server, too.

In addition, when building websites with Next.js, you still build React apps. That’s why Next.js apps become interactive on the client side once the SSR is done. **Technically, as you’ll also learn in the next chapter (React Server Components & Server Actions), they’ll be made interactive in a different way than in Vite-based SSR-enabled React apps (where React hydrates the server-side rendered markup on the client)**, but ultimately, your website users will have a SPA-like user experience.

Therefore, if you want to build a React app that supports SSR, relying on a framework like Next.js instead of setting up SSR manually is recommended.

In addition, you will be able to use other helpful features, like the file-based routing system, especially since it doesn’t stop at defining routes via page.js files. It, for example, also simplifies the process of defining layouts.

### Working with Layouts
As mentioned, when it comes to routing, file names and where you store those files matter.

For example, you’ll also find a layout.js file next to the page.js file in the app/ folder from the example above.

<img width="240" height="534" alt="image" src="https://github.com/user-attachments/assets/7bcaef22-fd69-4527-92d1-020421e158aa" />

**Just like `page.js`, `layout.js` is a reserved file name—i.e., that file is handled by Next.js in a special way.**

This `layout.js` file also exports a component function, but the created component will not be rendered for one specific path. Instead, **it is used as a wrapper around all sibling or nested pages. Thus, the `layout.js` file can be used to define JSX code that will be shared across multiple pages.**

Since it’s meant to be used as a wrapper component, the component function exported by layout.js must use the special children prop (see Chapter 3, Components & Props) to define the place where the wrapped page content should be displayed.

For example, you could use the `app/layout.js` file to define a global layout that adds a navigation bar above the `<main>` content:

```
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>
          <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/events">Events</a></li>
            </ul>
          </nav>
        </header>
        <main>{children}</main>
      </body>
    </html>
  );
}
```

In this example code snippet, it’s also worth noting that the `RootLayout` component renders the `<html>` and `<body>` elements. In Vite-based projects, that’s not something you would do. There, you instead define a place in the `index.html` file where the rendered HTML should be injected (via the `createRoot()` function exposed by the react-dom package; see Chapter 2, Understanding React Components & JSX).

Next.js **does not rely** on such an `index.html` file; instead, **it forces you to define a root `layout.js` file at the top level** of the `app/` folder. It’s then this root layout that must define the general structure of the rendered HTML page. However, **there is no `<head>` section in that file, since Next.js will manage and inject that section behind the scenes**. In addition, Next.js will **also insert JavaScript and CSS imports** into the rendered HTML document.

You may add more (nested) layout.js files if you want to have nested layouts that only wrap some of your pages. Such layouts are optional; the root layout (`app/layout.js`) **is mandatory**, however.

With a `layout.js` file like the one shown in the previous code example, in a project that contains an `app/page.js` file, and an `app/events/page.js` file, website users could visit both pages and see a shared navigation.

<img width="878" height="467" alt="image" src="https://github.com/user-attachments/assets/11c5a702-d9ff-4a92-a2fd-8af8d7ba9992" />

In Figure 15.8, the main content (defined by the page.js files) changes but the shared navigation (set up in layout.js) persists.

While sharing JSX markup is the most common use case for using layouts, you can also use them to share styles by importing a CSS file into a layout.js file:
```
import './globals.css';
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      Unchanged JSX code…
    </html>
  );
}
```

In this and the above examples, the component function is named RootLayout—that name does not matter, but it must be a component that’s exported.

Of course, layouts that are used to share a navigation bar become even more useful if you add working links to them…

### Managing Internal Navigation
In the previous code example, the <a> element was used for creating links between the different Next.js application pages.

However, just like other React apps, Next.js applications become SPAs once the initial page load is done. Therefore, creating internal links via <a> tags is discouraged for the same reasons it was discouraged when using React Router in Vite-based React projects (compare Chapter 13, Multipage Apps with React Router).

Like React Router, Next.js (which takes care of routing in Next.js projects) provides a special Link component that you should use for internal links (instead of the <a> element):
```
import Link from 'next/link';
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <header>
          <nav>
            <ul>
              <li><Link href="/">Home</Link></li>
              <li><Link href="/events">Events</Link></li>
            </ul>
          </nav>
        </header>
        <main>{children}</main>
      </body>
    </html>
  );
} 
```

This `<Link>` component accepts a `href` prop, which is set to the target path. **Internally, Next.js will capture link clicks and update the browser address bar and website UI accordingly by loading and rendering the required `page.js` components**.

### Highlighting Active Links & Using the “use client” Directive
If you want to style links differently when they lead to the currently active page, you won’t find a built-in NavLink component as is the case with React Router. Instead, you must add your own logic by setting the Link component’s className prop dynamically based on the currently active path.

To find out which path is currently active, you can use the usePathname() Hook provided by Next.js:
```
import { usePathname } from 'next/navigation';
const path = usePathname();
```

For example, you could adjust the layout.js file to look like this:
```
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import './globals.css';
export default function RootLayout({ children }) {
  const path = usePathname();
  return (
    <html lang="en">
      <body>
        <header>
          <nav>
            <ul>
              <li>
                <Link 
                  href="/" 
                  className={path === '/' ? 'active' : ''}>
                  Home
                </Link>
              </li>
              <li>
                <Link
                  href="/events"
                  className={path.startsWith(
                    '/events'
                  ) ? 'active' : ''}
                >
                  Events
                </Link>
              </li>
            </ul>
          </nav>
        </header>
        <main>{children}</main>
      </body>
    </html>
  );
}
```
However, if you were to run this code, you’d get an error message:
<img width="877" height="584" alt="image" src="https://github.com/user-attachments/assets/757437e8-4ebc-4c77-b5a5-51650e513a16" />

This error message sounds quite cryptic as it mentions a Client Component and Server Components. Both are crucial React concepts that will be explored in the next chapter (React Server Components & Server Actions).

For the current chapter, it’s enough to know the fix for this problem, which is to add the "use client" directive at the top of the app/layout.js file:

```
"use client";
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import './globals.css';
export default function RootLayout({ children }) {
  const path = usePathname();
  // return JSX code
}
```

"use client" is a so-called directive, i.e., an instruction that “tells” React and Next.js that this file must be handled in a special way. Adding it will get rid of the error message shown in Figure 15.9, thus enabling path-aware Link styling. As mentioned, the concrete impact of this directive will be explored in the next chapter.

❗ **Whenever you plan to use a Hook in a component in a Next.js project, the "use client" directive must be added—no matter if it’s a Hook provided by React or Next.js.**

#### Note

You might wonder why "use client" is required for components that use Hooks. After all, this directive was not needed when using SSR in Vite-based projects.

**The reason is that Next.js technically doesn’t use SSR**, as introduced at the beginning of this section. **Instead, Next.js (when using the App Router) uses a React feature called React Server Components**. This crucial feature will be explored in great detail in the next chapter. There, you’ll also learn why exactly "use client" is needed in some components.

### Creating & Using Regular Components
The `Link` component mentioned in the previous sections is a component offered by Next.js. But, of course, you can also build your own components—it is still a React app after all.

Besides the components that are exposed as pages (page.js) or layouts (layout.js), you can create and use component functions in any files (with any names) of your choice.

For example, you can add a `components/` folder next to the `app/` folder and add a `MainNavigation.js` file in it. This file can then hold a new `MainNavigation` component that returns the navigation-related JSX code:

```
'use client';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
export default function MainNavigation() {
  const path = usePathname();
  
  return (
    <header>
      <nav>
        <ul>
          <li>
            <Link href="/" className={path === '/' ? 'active' : ''}>
              Home
            </Link>
          </li>
          <li>
            <Link
              href="/events"
              className={path === '/events' ? 'active' : ''}
            >
              Events
            </Link>
          </li>
        </ul>
      </nav>
    </header>
  );
}
```

Please note that "use client" must be added at the top of this MainNavigation.js file since the usePathname() Hook is used in the component function.

With the code moved into this newly added MainNavigation component, inside the layout.js file, "use client" can be removed since the usePathname() Hook is no longer used in that file. It’s used in a child component (inside <MainNavigation/>) but React does not care about this.

Hence, the updated layout.js file looks like this:
```
import './globals.css';
import MainNavigation from '../components/MainNavigation';
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <MainNavigation />
        <main>{children}</main>
      </body>
    </html>
  );
}
```

Thanks to building, outsourcing, and using the custom MainNavigation component, the updated layout.js file therefore contains a lean and concise component function again.

#### Note

With the exception of the route-related files, it is entirely up to you how you structure your Next.js project and how you name your files.

As mentioned, you can store custom (non-page) components in a components/ folder (or a folder with any other name of your choice) in any place of your choice. You can put that components/ folder into the app/ folder or into the root project folder.

You can also not use a components/ folder at all, and instead store components in files that are located next to your page.js files. Because if a file is not named page.js, it won’t be treated as a page—so there is no danger of accidentally creating routes you don’t want in your project. If you have an app/components/MainNavigation.js but no app/components/page.js file, there won’t be a /components route. Files not named page.js (or one of the other reserved filenames—see the upcoming section Other Filename Conventions) will simply be ignored by Next.js (for routing purposes).

You find more information and ideas regarding Next.js project organization in the official documentation: https://nextjs.org/docs/app/building-your-application/routing/colocation.

### Handling Dynamic Routes
As you learned in Chapter 13, Multipage Apps with React Router, in the From Static to Dynamic Routes section, many React apps need to support dynamic routes, too.

For example, you might want to allow your users to visit /events/e1 to view the details for an event with ID e1 and /events/e2 for an event with ID e2 (and so on).

This is such a common requirement that Next.js, of course, supports it. You can add dynamic routes in a Next.js app by creating a folder (somewhere in the app/ folder) that has its name wrapped by square brackets—for example, app/events/[eventId]. Of course, you still need a page.js file in that folder to actually create a route.

The part between the square brackets (eventId, in this example) is entirely up to you. But the square brackets tell Next.js that you’re setting up a dynamic route.

The folder name between the square brackets acts as an identifier that can be used to retrieve the concrete value encoded in the URL (e.g., to retrieve e1 in /events/e1).

Every component that’s used as a page (or layout) receives a params prop that’s automatically set by Next.js. If it’s a page or layout in a dynamic route folder or in some nested child folder, the params prop will hold a Promise which resolves to an object that contains the chosen identifiers (like eventId) as keys and the concrete URL path values (like e1) as values for those keys. Since params holds a Promise, await must be used on it to get access to the underlying object.

For example, the `app/events/[eventId]/page.js` file would ensure that the component exported inside the `page.js` file gets rendered for visits to `/events/e1`, `/events/e2`, etc. This page component can then output event details with the help of the following code:

```
// getEventById is a custom dummy function to load event data
import { getEventById } from '@/lib/events'; 
export default async function EventDetailsPage({ params }) {
  // params.eventId exists because of folder name => [eventId]
  const { eventId } = await params; 
  const event = getEventById(eventId);
  return (
    <div id="event-details">
      <header>
        <img src={`/${event.image}`} alt={event.title} />
        <h1>{event.title}</h1>
        <p>
          {event.location} | {event.date}
        </p>
      </header>
      <p>{event.description}</p>
      <p>
        <button>Register</button>
      </p>
    </div>
  );
}
```

In this example, the automatically provided params prop is used to get access to the eventId encoded in the URL. If some other identifier than eventId would be used in the folder name, that alternative name would be used to access the path value (e.g., for [id]/page.js, you’d access (await params).id).

As a result, users can visit this dynamic route and explore the event details for a chosen event ID.

<img width="749" height="944" alt="image" src="https://github.com/user-attachments/assets/3fdbf7bc-b1a6-4503-9c5e-767db6470d46" />

#### Note

You can find the complete example code, including the lib/events.js file, on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/08-nextjs-dynamic-routes.

Of course, when working with dynamic routes, you typically also need links to those dynamic paths in some parts of your application. Therefore, in this example, the app/events/page.js file contains code that dynamically renders a list of event items, where every item has a link to its detail page:
```
import Link from 'next/link';
import { getEvents } from '@/lib/events';
export default function EventsPage() {
  const events = getEvents();
  return (
    <div id="events">
      <h2>Browse available events</h2>
      <ul>
        {events.map((event) => (
          <li key={event.id}>
            <img src={event.image} alt={event.title} />
            <div>
              <h2>{event.title}</h2>
              <p>{event.description}</p>
              <p>
                <Link 
                  href={`/events/${event.id}`}>Explore Event</Link>
              </p>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Clicking these links will take users to the event detail page for the specific event ID.

#### Note

Static routes, dynamic routes, and nested routes are the most important route types you need to know when working with Next.js. You’ll use them for most of your routes.

In addition, Next.js also offers other (more advanced and niche) route types and features that are worth exploring if you decide to dive deeper into Next.js: https://nextjs.org/docs/app/building-your-application/routing.

### Other Filename Conventions
Next.js does not just offer a variety of route types and routing-related features—it also offers more reserved filenames than just page.js and layout.js.

Therefore, when working with the Next.js App Router, you should also be aware that the following reserved filenames exist, too:

- `loading.js` files can be added next to or above page.js and layout.js files to define components that should be displayed whilst the page (or layout) component is fetching data.
- `error.js` files can be added in the same places as loading.js files to render error fallback components in case one of the sibling or child pages throws an error.
- `not-found.js` files can be added to display fallback content in case a website visitor tries to load a non-existent route or resource.
- `route.js` files can be added to set up routes that do not render components but instead return data (e.g., in the JSON format).

You can learn more about these file types and even more file name conventions in the official documentation: https://nextjs.org/docs/app/building-your-application/routing#file-conventions.

You’ll also see some of these file types in action in the next chapter.

### Diving Deeper into Next.js
At this point, you have a solid Next.js foundation but, as mentioned in the previous section, you can dive deeper into Next.js with the help of the official documentation.

There, besides learning more about routing, route types, and filenames, you can also explore how Next.js helps with caching, styling, or managing page metadata. Since this book is primarily about React itself, and not about Next.js, covering all these topics here would quickly bloat this book.

That’s why this chapter focused on setting a solid React SSR and Next.js foundation. The essentials covered throughout this chapter will help with understanding more advanced React and Next.js features like React Server Components in the next chapter. In addition, thanks to these fundamentals, you’ll also be able to quickly learn more about Next.js with the help of the official documentation or dedicated Next.js books or courses.

### Summary and Key Takeaways
- By default, Vite-based React apps (like most React apps that don’t use Next.js or a similar framework) only support client-side rendering.
- Without SSR, a relatively empty index.html file is sent to the client.
- This can lead to bad user experiences (if users see an empty page for a prolonged period) or suboptimal search engine ranking.
- You can enable SSR by manually adjusting React projects (code and build process) to support component function execution on the server side.
- To avoid custom SSR setup work and take advantage of many other benefits, you can use frameworks like Next.js.
- Next.js projects come with built-in SSR support and can be created via the npx create-next-app command.
- Modern Next.js uses the App Router approach, which takes advantage of an app/ directory that is used for setting up routes with the help of the file system.
- Inside app/, you define pages by creating folders that contain page.js files (e.g., app/about/page.js adds support for an /about route).
- To share JSX code (and logic or styles) across pages, you can add layout.js files.
- Next.js also offers other reserved filenames to handle fallback content that’s shown while loading data or to handle errors.
- You can link between pages via Next.js’ Link component.
- When using React Hooks (like useState() or Next.js’ useRouter()), you must add the "use client" directive at the top of the file that uses the Hook.
- Besides static pages (like app/events/page.js or app/about/page.js), you can also set up dynamic pages by enclosing a folder name with square brackets (e.g., `app/events/[eventId]/page.js`).
- Dynamic path parameter values can be extracted in the loaded page component by using the special params prop that’s set on the component by Next.js.
- Asynchronous operations can be problematic when using SSR—or, at least, they can’t be executed in components that are rendered on the server, hence forcing the client-side code to perform them. At least when not using React Server Components.

What’s Next?
At this point, you have learned a lot about SSR in React apps and about Next.js. You’re able to create Next.js projects, define routes, render page components, add navigation, and work with dynamic paths.

You also learned that Next.js comes with built-in SSR. Thus, all React components (built-in and custom, page and non-page) are rendered on the server when a website visitor sends a request.

Modern Next.js does not stop there, though—instead, unlike the custom SSR setup introduced at the beginning of this chapter, Next.js projects that use the App Router help with asynchronous data fetching on the server side by unlocking React’s React Server Component feature. It’s that feature, and Server Actions, that will be explored in great detail in the next chapter!

### Test Your Knowledge!
Test your knowledge of the concepts covered in this chapter by answering the following questions. You can then compare your answers to examples that can be found at https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/15-ssr-next-intro/exercises/questions-answers.md:

Which two main advantages can SSR offer?
What are some potential disadvantages or weaknesses of SSR?
How does Next.js help with SSR?
How are routes configured in Next.js (when using the “App Router”)?
What’s special about a page component in Next.js?
What’s the purpose of layout components in Next.js?
Where can you store non-page (and non-layout) React components in a Next.js project?
When and where do you need to add the "use client" directive?
Apply What You Learned
With all the newly gained knowledge about Next.js, it’s time to apply it to a real demo project—a demo application that will be rendered on the server.

In the following section, you’ll find an activity that allows you to practice working with Next.js. As always, you will also need to employ some of the concepts covered in earlier chapters.

### Activity 15.1: Migrating a Vite-Based React Router App
In this activity, your job is to build upon the Vite-based app from Activity 13.1. That app was built with Vite and React Router. Your job is to migrate it from Vite and React Router to Next.js.

Therefore, you should create a new Next.js project (using the App Router) and rebuild the same app in that project.

#### Note

You can find the starting code for this activity at https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1-start. When downloading this code, you’ll always download the entire repository. Make sure to then navigate to the subfolder with the starting code (activities/practice-1-start, in this case) to use the right code snapshot.

Since your task is to migrate the project that was built in Activity 13.1, you might also want to use the finished code from that activity. You can find it here: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1.

After downloading the code and running npm install in the project folder to install all required dependencies, the solution steps are as follows:

If you created a new Next.js project (i.e., if you’re not using the provided starting snapshot), clean up the layout.js and page.js files to remove everything but the component functions.
Create two new routes: a /products route and a /products/<some-id> route.
Migrate the data.js file into the Next.js project (e.g., into a lib/ folder in the root project folder).
Update the page components to load and display the data provided by the data.js file.
Create a new components/ folder and migrate (copy) the MainNavigation component into this folder.
Update the MainNavigation component (and any other component that needs it) to use Next.js’ Link component.
Highlight active links with the help of the usePathname() Hook—don’t forget about the "use client" directive!
Migrate the styles from the index.css file into the globals.css file. Make sure that the file gets imported into the root layout file.
The expected result should look as shown in the following screenshots:

<img width="877" height="154" alt="image" src="https://github.com/user-attachments/assets/5e833aed-ae7b-409d-a221-66892a5c377f" />

Figure 15.11: The home page content

<img width="877" height="252" alt="image" src="https://github.com/user-attachments/assets/a69263b6-9e02-4ecd-8c70-f8472f6c570f" />

Figure 15.12: The /products page content

<img width="878" height="249" alt="image" src="https://github.com/user-attachments/assets/2f34de94-d5a9-439f-b3bf-7f0545636d48" />

Figure 15.13: The /products/<some-id> page content

#### Note

You will find the full code for this activity, and an example solution, here: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/activities/practice-1.

