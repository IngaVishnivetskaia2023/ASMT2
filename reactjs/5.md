## Server-side Rendering & Building Fullstack Apps with Next.js

#### Learning Objectives

By the end of this chapter, you will be able to do the following:

- Describe the difference between client-side and server-side React
- Determine which kind of React app to build
- Build fullstack React apps with the help of the Next.js framework
- Explain the key features and advantages of Next.js

### Introduction
Thus far in this book, you have learned a lot about building client-side React applications, that is, applications where the (transpiled) React code executes in the browsers of your website visitors.

This makes sense because React was originally created to simplify the process of building interactive and reactive UIs by running JavaScript code on the client side. 
To this date, most React features, including the ones covered up to this point in this book (e.g., state, context, and routing), exist to fulfill this purpose.

But, as you will learn in this and the following chapters, you can actually also **execute React code on the server side**. 
There are certain React features that may only be used there—for example, **React Server Components**, which will be covered in great detail in the Chapter 16, React Server Components & Server Actions.

This chapter will get you started with React on the server side, briefly explain what **server-side rendering (SSR)** is, and introduce you to Next.js, a popular and feature-rich fullstack framework for React that allows you to blend backend and frontend code. 
You will learn how to create Next.js apps and how to use core Next.js features like file-based routing.

### What’s the Problem with Client-Side React Apps?
The big advantage of single-page applications (SPAs) and client-side React is that you can build highly reactive and interactive web UIs. The UI can be updated almost instantly, visible page reloads and switches can be avoided, and hence your users benefit from a mobile-app-like user experience.

But this reliance on client-side code (and, therefore, JavaScript) also has potential disadvantages:

- If users disable JavaScript, the website will be pretty much unusable.
- The **initially fetched HTML document is almost empty** — data fetching and content rendering only take place **after that initial HTTP request and response**.


The first point might not matter too much, since only a small subset of all users will disable JavaScript and you can show an appropriate warning message via the `<noscript>` tag.

But the second point can have significant consequences. Since the initial HTML document is almost empty, users won’t see any content until all the JavaScript code has been fetched and executed. While most users might not see a notable delay, depending on the device and internet connection of a user, this may take up to a few seconds for some users.

In addition, search engine crawlers (e.g., Google’s crawler) will not necessarily wait for all your client-side JavaScript code to be fetched and executed when indexing your page. Therefore, those crawlers may see a mostly empty page and hence rank your website badly (or not index it at all).

<img width="877" height="311" alt="image" src="https://github.com/user-attachments/assets/e08fd8a1-07a3-4c99-81f6-85766ff7dca0" />

Figure 15.1 shows the page source code (which can be inspected by right-clicking on the website) of a typical React app. As you can see in that figure, there’s almost no content between the <body> tags. The title ("Hello World!") and the text below it are missing in that source code. The content is missing there because it’s not part of the initial HTTP response. Instead, it’s rendered by the transpiled React code after the page loaded (and after that code was downloaded from the server).

Of course, these disadvantages won’t matter in all cases. If you’re building some company-internal application, or a UI that’s hidden behind some login (and hence won’t be indexed anyway), or if you’re only targeting users with fast devices and internet connections, you might not need to worry about these potential problems.

But if you’re building **a public-facing website where search engine indexing matters** or that may be visited by users with slow devices or internet connections, you might want to consider getting rid of these disadvantages. And that’s precisely **where SSR can help out**.

### Making Sense of Server-side Rendering (SSR)
When working with React, **SSR refers to the process of rendering web pages**, and therefore your React components, on the server that handles the incoming HTTP request when a user visits your website.

With SSR enabled, **the server will render your React component tree and hence produce the actual HTML code yielded by your components and their JSX instructions**. It’s **this finished HTML code that’s then sent back to the client**. As a result, website visitors will receive an HTML file that’s not empty anymore but that instead contains the actual page content. Search engine crawlers will also see that content and index the page accordingly.

<img width="666" height="456" alt="image" src="https://github.com/user-attachments/assets/098bee97-5f2e-4a5d-9c0b-ec798d2f1641" />

Best of all, you don’t lose the client-side advantages of React because, when enabling SSR, React still works on the client side as it did before! It’ll take over control once that initial HTML document has been received and provide users with the same SPA experience you were able to deliver without SSR. Though, **technically, when using SSR, React will be initialized slightly differently on the client. Instead of re-rendering the entire DOM there, it’ll hydrate the page content that was rendered on the server. Hydration means that React will connect your component structure to the rendered HTML code (which was rendered based on that same structure, of course) and make it interactive**.

<img width="658" height="440" alt="image" src="https://github.com/user-attachments/assets/b0aae3ab-b37d-4ba3-8c88-eeb501883659" />

#### SSR (Server-Side Rendering):
сервер рендерит React-компоненты в HTML и отдаёт готовую страницу пользователю, поэтому он видит содержимое быстрее.

#### Гидрация (hydration):
когда браузер загружает JS-приложение, React «подключает» свою структуру к уже отрендеренному сервером HTML, навешивает обработчики событий и делает страницу интерактивной, не перерисовывая её целиком.

#### Пошаговый разбор (детально):

<img width="854" height="866" alt="Снимок экрана (328)" src="https://github.com/user-attachments/assets/e9f8727b-ad3e-4498-b707-d0c438c8896f" />


1. Запрос пользователя — браузер делает HTTP `GET` к серверу (например, /).

2. Сервер рендерит React — на сервере вызывается `renderToString` (или `renderToPipeableStream`), который превращает компонент `App` в HTML-строку. Сервер может подставить начальные данные (props) в компонент перед рендером.

3. Сервер отдаёт HTML — клиент получает готовую страницу: полностью сформированный DOM (в `<div id="root">...</div>` лежит HTML приложения).

4. Первичная отрисовка в браузере — пользователь сразу видит контент (лучший `UX`, `SEO` и стартовый `paint` быстрее).

5. Загрузка JavaScript — браузер загружает и парсит клиентский бандл (`client.js`). До этого интерактивность (клики, формы) не работает — это просто статический `HTML`.

6. Гидрация — в `client.js` вызывается `hydrateRoot(document.getElementById('root'), <App .../>)`. React сравнивает свою виртуальную структуру с существующим DOM и "присоединяется" к нему, навешивая обработчики событий, создавая внутренние структуры (`fibers`) и синхронизируя состояние.

7. SPA-поведение — после успешной гидрации приложение полностью интерактивно и работает как обычное одностраничное приложение (SPA).

#### Что именно делает гидрация (technical)

- React при гидрации не создаёт все DOM-узлы заново (в идеальном случае). Вместо этого он сопоставляет (reconcile) виртуальные элементы с уже существующим DOM, чтобы переиспользовать узлы.
- Гидрация навешивает обработчики событий, создает внутренние структуры React (fibers) и начинает отслеживать состояние компонентов.
- Если HTML, сгенерированный сервером, не совпадает с тем, что React ожидает при рендере на клиенте, будет предупреждение о mismatch, и React может выполнить исправление — перерендерить часть или весь DOM.

### Adding SSR to a React Application
It is extremely important to understand that SSR-enabled React applications need to execute code in two environments (server and browser), whereas client-side React applications only rely on the browser. Therefore, to use SSR, a server-side environment must be added to the React project—it’s not enough to just adjust the React code in a few places.

For example, standard Vite-based projects don’t support SSR out of the box. Consequently, if you want to support SSR, you must edit your Vite project setup (and some of your project code files) to enable executing React code on both the client and server side. For example, you must add some code that handles incoming HTTP requests and triggers React code execution on the server side.


#### Note

Manually enabling SSR requires backend development and build process configuration knowledge—in addition to the React knowledge you need.

Thankfully, though, as you’ll learn throughout this chapter, you often don’t need to go through that setup process. Instead, you can rely on frameworks like Next.js to do the heavy lifting for you.

If you’re interested in manually configuring SSR in Vite-based projects, the official Vite SSR documentation is a great place to learn more: https://vitejs.dev/guide/ssr.

In addition, you can explore the following demo project that was set up according to the official Vite SSR instructions: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/02-ssr-enabled.


The fact that manually enabling SSR is a non-trivial process that requires advanced Node.js and backend development knowledge is one of the reasons why the official React documentation recommends creating new React projects with the help of frameworks like Next.js (see https://react.dev/learn/start-a-new-react-project).

But it’s not the only reason.

### Server-side Data Fetching Is Not Trivial

Besides the non-trivial setup process, SSR-enabled projects also suffer from another possible problem: server-side data fetching is difficult.

If you’re building a React app that needs to fetch data in some components (e.g., with the help of useEffect(), as shown in Chapter 8, Handling Side Effects), you’ll find out that the data is not fetched when the component is rendered on the server. Instead, the data fetching will only occur on the client side. The server-side rendered HTML markup will not contain the content that depends on the fetched data.

The reason for this behavior is that React component functions are only executed on the server once—i.e., it’s only the first component render cycle that’s performed on the server. You can think of SSR producing only an initial page snapshot. Subsequent state updates are ignored, and effect functions (triggered via useEffect()) are also therefore not executed on the server side. As a result, data fetching that relies on effect functions and subsequent state updates will not work on the server side.

Consider this example, where a Todos component function uses useEffect() to fetch some (dummy) to-dos data from https://jsonplaceholder.typicode.com/:

```
import { useEffect, useState } from 'react';
import { loadTodos, saveTodo } from '../todos.js';
function Todos() {
  const [todos, setTodos] = useState();
  useEffect(() => {
    async function fetchTodos() {
      // sends HTTP request to jsonplaceholder.typicode.com
      const todos = await loadTodos();
      setTodos(todos);
    }
    fetchTodos();
  }, []);
  async function addTodoAction(fd) {
    const todo = {
      title: fd.get('title'),
    };
    const savedTodo = await saveTodo(todo);
    setTodos((prevTodos) => [savedTodo, ...prevTodos]);
  }
  return (
    <section>
      <h2>Manage your todos</h2>
      <form action={addTodoAction}>
        <input type="text" name="title" />
        <button type="submit">Add Todo</button>
      </form>
      {(!todos || todos.length === 0) && (
        <p>No todos found.</p>
      )}
      {todos && todos.length > 0 && (
        <ul>
          {todos.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      )}
    </section>
  );
}
```

#### Note
You find the complete example code on GitHub: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/15-ssr-next-intro/examples/03-ssr-data-fetching.

When running this code on the server, there won’t be any errors. Instead, the app will run as expected and fetch the dummy to-dos from the backend server.

However, the HTML document that’s produced on the server will not contain the fetched to-dos. Instead, it will just contain the fallback text ("No todos found").

The generated markup does not contain the fetched to-dos because, as explained above, React component functions only execute once on the server side (and the function passed to useEffect() doesn’t execute at all).

Due to this behavior, you can’t easily perform asynchronous operations and, for example, fetch data via useEffect() in your React components when using SSR. Hence, the server-side rendered HTML content will never contain that data.

While you can come up with workarounds to that problem (e.g., perform the data fetching operation on the server, before executing the component functions) that’s a problem that will be solved by Next.js and a concept called `React Server Components (RSC)`.


#### Почему useEffect не выполняется на сервере:

- При SSR React рендерит компоненты только один раз на сервере — это первый рендер.

- На сервере нет полноценного жизненного цикла React-компонента: отсутствует фаза `commit`, в которой запускаются эффекты.

- `useEffect` всегда планируется **после монтирования компонента**, но на сервере нет `DOM` и нет понятия "монтирования" в браузерный интерфейс, поэтому React просто игнорирует этот код.

- Это не ошибка — React сознательно не выполняет эффекты на сервере, так как они часто зависят от браузерных API (window, document, события и т.п.).

- В результате код в `useEffect` (например, запросы к API) будет выполнен только на клиенте, уже после гидрации.

- Поэтому HTML, который отдаёт сервер, содержит только "пустое" или fallback-состояние (например, "No todos found").


### Introducing Next.js
Next.js is a React framework—i.e., a framework that builds upon React and adds extra features and patterns to it. Specifically, Next.js adds features like file-based routing, built-in SSR, or automatic caching to improve performance. Though, most importantly, it unlocks two crucial React concepts: **React Server Components (RSC)** and **Server Actions**. As you will learn, these features enable server-side React code to perform asynchronous operations and, for example, fetch and render data on the server.

Thus, Next.js saves you the effort of manually enabling SSR, and, additionally, unlocks other powerful features that help with fetching data on the server.


