## Components and Props

### Spreading Props

Imagine you’re building a custom component that should act as a “wrapper” around some other component—a built-in component, perhaps.

For instance, you could be building a custom `Link` component that should return a standard <a> element with some custom styling or logic added:
```
function Link({children}) {
  return <a target="_blank" rel="noopener noreferrer">{children}</a>;
};
```


This very simple example component returns a pre-configured `<a>` element. 
This custom Link component configures the anchor element such that new pages are always opened in a new tab. 
In place of the standard `<a>` element, you could use this `Link` component in your React app to get that behavior out of the box for all your links.

But this custom component suffers from a problem: it’s a wrapper around a core element, but by creating your own component, you remove the configurability of that core element. 
If you were to use this `Link` component in your app, how would you set the `href` prop to configure the link destination?

You might try the following:
```
<Link href="https://some-site.com">Click here</Link>
```


However, this example code wouldn’t work because `Link` doesn’t accept or use a `href` prop.

Of course, you could adjust the Link component function such that a href prop is used:
```
function Link({children, href}) {
  return <a href={href} target="_blank" rel="noopener noreferrer">{children}</a>;
};
```

But what if you also wanted to ensure that the download prop could be added if needed?

Well, it’s true that you can always accept more and more props (and pass them on to the <a> element inside your component), but this reduces the reusability and maintainability of your custom component.

A better solution is to use the standard JavaScript spread operator (i.e., the ... operator) and React’s support for that operator when working with components.

For example, the following component code is valid:
```
function Link({children, config}) {
  return <a {...config} target="_blank" rel="noopener noreferrer">{children}</a>;
};
```

In this example, config is expected to be a JavaScript object (i.e., a collection of key-value pairs). 
The spread operator `(...)`, **when used in JSX code on a JSX element**, converts that object **into multiple props**.

Consider this example config value:
```
const config = { href: 'https://some-site.com', download: true };
```

In this case, when spreading it on `<a>`, (i.e., `<a {…config}>`), the result would be the same as if you had written this code:
```
<a href="https://some-site.com" download={true}>
```

An alternative, **more common pattern** uses yet another JavaScript feature: **the rest property**. 
That’s a JavaScript pattern that allows you **to group properties that have not been destructured into a new object** (which then only contains those properties).
```
function Link({children, ...props}) {
  return <a {...props} target="_blank" rel="noopener noreferrer">{children}</a>;
};
```
In this example, when destructuring props, only the children prop is destructured; the other ones are stored in a new object named props. 
The syntax is very similar to the spread operator syntax: you use three dots `(...)`. 
But here, you use the operator in front of the property that should contain all remaining properties. Therefore, it’s the place where you use that operator that defines what it does.

You can then use that rest property (props in the example) like any other object. In the example above, it’s again used to spread its properties as props onto the `<a>` element.

❗ Using this pattern allows you to use the `Link` component in a more natural way, where **you don’t have to create and use a separate configuration object**:
```
<Link href="https://google.com">Can you google that for me?</Link>
```

These behaviors and patterns can be used to build reusable components that should still maintain the configurability of the core element they may be wrapping. This helps you avoid long lists of pre-defined, accepted props and improves the reusability of components.
