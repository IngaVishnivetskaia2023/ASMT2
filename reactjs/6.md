## React Server Components & Server Actions
Learning Objectives

By the end of this chapter, you will be able to do the following:

- Create and use React Server Components (RSCs)
- Describe how (and when) RSCs are executed and rendered to the screen
- Fetch data and perform asynchronous operations with the help of RSCs
- Draw server-client boundaries by building and using client components
- Perform server-side data mutations with the help of Server Actions
- Update the user interface (UI) in response to Server Actions


### Introduction
In the previous chapter, you learned that you can use server-side rendering (SSR) to render React components on the server. SSR ensures that users receive a fully populated HTML document upon their initial HTTP request, not an almost empty page shell. You were also introduced to Next.js and learned how you may use that framework to build React apps that come with SSR (and many other useful features) out of the box.

This chapter builds upon the previous one—specifically, you’ll learn about two crucial React features that are unlocked by Next.js: React Server Components (RSCs) and Server Actions.

Throughout this chapter, you’ll learn how these two features help with data fetching and mutations, and **why you can’t use them in every React project**, even though they’re technically part of React—not Next.js.

#### Note

RSCs and Server Actions are relatively new React features. Supporting them in custom React projects is tricky, as you will learn throughout this chapter.

Whilst unlikely, it is possible that concepts or features related to RSCs or Server Actions change. It’s also possible that supporting these features in custom projects gets easier.

That’s why this book comes with a dedicated document that tracks any significant changes you should be aware of: https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md.

### The Problem with Server-side Data Fetching
If you have an SSR-enabled React app, either by manually enabling it, for example, in a Vite-based project, or by using a framework like Next.js, 
**your React component functions get executed on the server**. Thus, any data required by those components **should be fetched on the server**.

But as explained in the previous chapter, in the Server-side Data Fetching Is Not Trivial section, 
sending HTTP requests with the help of `useEffect()` or trying to update the UI via `useState()` **does not work when using SSR**. 
On the server, React only calls the component functions **once** — it does not re-execute them when the state changes. It also **doesn’t call** your effect functions.


This is a serious limitation since many React apps need to fetch data from some backend or a database. Not being able to fetch and render that data on the server means that website visitors will again receive incomplete HTML documents (and wait for the data to be fetched on the client side), and search engine crawlers will not see the most important content of the web page.

That’s one of the reasons why React introduced RSCs.

### Introducing RSCs
RSCs, despite their name, are not necessarily components that run on a server. Instead, their defining characteristic is that their component functions are never, under any circumstances, executed on the client side!

Consequently, RSCs may be executed on a server, but they may also be called during the build process, hence pre-generating components at build time. 
**They definitely won’t be executed in the browser, though.**

<img width="877" height="447" alt="image" src="https://github.com/user-attachments/assets/837ac1b1-5cda-43ed-bd51-0da6b23bdcd0" />

### Making Sense of RSCs
The core idea behind RSCs is that you can build components that render outside of the browser (e.g., on the server). As a result, these components can execute code that wouldn’t work in the browser—for example, because Node.js-specific APIs are used, or code that relies on credentials (e.g., database credentials) that must not be exposed to the client.

Unlike “normal” components (client components) that are rendered via SSR, RSCs can be rendered (on the server) after the initial page load. Hence, RSCs are not just about rendering an initial page snapshot. In addition, RSCs can fetch data on the server side. Later in this chapter, the RSCs vs Server-side Rendering section will take a closer look at the relationship between RSCs and “normal” components rendered via SSR.

Hence, RSCs solve an important problem: they allow you to intertwine frontend and backend React code. Whereas, in the past, before RSCs, you typically had to build separate backend and frontend web applications, you can now build integrated fullstack apps that blend server-side and client-side React code.


Using RSCs therefore offers various advantages:

- Building fully integrated fullstack applications where the backend and frontend are closely connected and use the same server becomes much easier.
- Asynchronous server-side data fetching inside of components becomes possible: Unlike on the client side (or when using SSR), React allows you to use async/await and return a Promise value in your component functions.
- Website visitors download smaller client-side JavaScript bundles since the code of RSCs is omitted.
- Running compute-heavy operations or using large third-party libraries gets easier since the operations and their code can be outsourced to the server (or to the build process).
- Code or credentials that shouldn’t be accessible by your website users can be moved into RSCs.


For example, thanks to RSCs, you can create components like this:
```
import pg from 'pg'; // pg package (more info: node-postgres.com)
const { Client } = pg
 
const client = new Client({
  user: 'username',
  password: 'your-password',
  host: 'my.database-server.com',
  port: 5334,
  database: 'demo',
});
async function ProductsPage() {
  await client.connect();
  const res = await client.query('SELECT * FROM products'); 
  await client.end();
  return (
    <ul>
      {res.rows.map(row => <li key={row.id}>{row.title}</li>)}
    </ul>
  );
}
```

The ProductsPage component contains code that reaches out to a PostgreSQL database to fetch product data from there.

Without RSCs, this kind of component would be impossible to build and use. You wouldn’t be allowed to use async/await, the pg package might rely on some APIs that are not available in the browser, and you would expose your database credentials in the client-side code bundle.

All these things are allowed when building RSCs. React explicitly does allow you to return a Promise (and hence use async/await) when building an RSC. Since the code is guaranteed to never end up on the client side, connecting to a database is safe, too.

Therefore, you can easily build fully integrated fullstack apps where backend and frontend code blend seamlessly.

However, using RSCs is both simple and complex at the same time, as the next section will explain.

### Creating & Using RSCs
In a Next.js project that uses the App Router, **all React components, no matter if used as pages or nested in some other component, are, by default, RSCs**.

As you can tell if you inspect any React component function in a Next.js project, there really is nothing special about them. They look like regular React components:
```
export default function ServerComponentInfo() {
  return <p>This is a React Server Component.</p>;
}
```

You may use async/await with them, but you don’t have to. You may use server-side APIs and packages, but you don’t have to. So, creating RSCs is simple—they’re just normal components after all.

The same is true for using them—you use them as you always used React components: as custom JSX elements:
```
<ServerComponentInfo />
```
As you can see, you wouldn’t be able to tell that this is a special kind of component. It’s created and used as you learned it through this entire book.

Nonetheless, all the other components from all the other chapters of this book, **which were used in Vite-based React projects, were not RSCs**. They were regular components or **client components**.

So, what makes the components in a Next.js project special? Why is a feature provided by React available in Next.js projects but not necessarily in other React projects (e.g., in Vite-based projects)?

### Unlocking RSCs in React Projects
**RSCs are a feature provided by React, not Next.js**. Yet, not all React projects can use this feature.

The reason for that, and for why RSCs are available in Next.js projects, is the Next.js build process and what Next.js does to these components (and to the entire React project code, actually) behind the scenes. 

#### At a high level, you can think of Next.js doing the following things:

- The build workflow and bundling process separates server and client components to ensure that no RSC code ends up on the client side.
- Next.js sets up API endpoints (i.e., URL addresses to which the client-side code may send requests) that trigger RSC component functions on the server and return instructions that allow the client-side React code to update the UI.
- Next.js calls these endpoints when needed—for example, when navigating to a new page.
- Next.js passes the API response (which contains these rendering instructions) to React, which uses the returned instructions to update the UI as needed.

<img width="878" height="481" alt="image" src="https://github.com/user-attachments/assets/1f05973e-1985-4151-8eb2-7caa26b57355" />
Figure 16.2: Client and server component code are separated; communication happens via HTTP requests

Technically, it’s a bit more complex than that, but for the purpose of this book and for using the feature, a deep understanding of the internals is not required—just as you don’t need to understand what exactly happens internally when using `useState()`, for example.

You can verify the mentioned points by running a demo Next.js project you find here: https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/16-rsc-server-actions/examples/01-rsc-intro.

This demo app consists of two basic page component files: app/page.js and app/info/page.js. The main page component (the Home component inside app/page.js) outputs a ServerComponentInfo component:
```
import ServerComponentInfo from '../components/ServerComponentInfo';
export default function Home() {
  return <ServerComponentInfo />;
}
```

That component in turn simply outputs some static, hardcoded content:
```
import Link from 'next/link';
export default function ServerComponentInfo() {
  return (
    <div id="rsc-info">
      <p>This is a React Server Component.</p>
      <p><Link href="/info">Learn More</Link></p>
    </div>
  );
}
```

Both the Home and the ServerComponentInfo components are RSCs—simply because they are components in a Next.js project. As mentioned earlier, all components in Next.js projects are server components by default. If these components were part of a Vite-based React project that is not set up to support RSCs, these components would instead be “normal” components (client components).

In the same demo project, there is also a component for the /info page. This component contains some code that wouldn’t work in a component that isn’t an RSC:

```
import fs from 'node:fs/promises';
export default async function InfoPage() {
  const info = await fs.readFile('data/rsc-info.json', 'utf-8');
  const { summary } = JSON.parse(info);
  
  return (
    <div id="info-page">
      <h1>Understanding React Server Components</h1>
      <p>
        {summary}
      </p>
    </div>
  );
}
```

This code wouldn’t work in any of the (Vite-based) React projects you saw before in this book because of the following reasons:

- The InfoPage component uses Node’s `fs` package to load data from a rsc-info.json file (which is part of the project).
- The component uses async/await, hence returning a Promise that eventually yields the JSX code (i.e., the React elements).

In projects that do not support RSCs, you’re not able to use server-side APIs since all the code runs in the browser. You’re also not allowed to return a Promise in your components. In non-RSCs, that would not be considered a valid component function return value. When working with RSCs, both things are allowed and possible, though.

As mentioned in the Making Sense of RSCs section, using server-side functionalities (like Node.js APIs) is something that’s unlocked because the InfoPage component, like all components in Next.js projects, is an RSC. For RSCs, React also supports the usage of async/await.

Consequently, as expected, you won’t find the code of the InfoPage component in the client-side JavaScript code bundles. You can verify this by visiting the /info page. If you open the Network tab in the browser developer tools, and you then reload the page, you’ll see all the HTTP requests sent to the server. This includes all requests for JavaScript code files that are needed on the client side of this React app.

<img width="877" height="499" alt="image" src="https://github.com/user-attachments/assets/daece4ac-8cec-4887-b8e3-11b7a5872c12" />

Figure 16.3: When visiting /info, requests for CSS, JS, and some other files are sent to the server

If you then go through all the JavaScript files requested and search for rsc-info.json in the downloaded code files, you won’t have any matches in any file. This proves that this code, which is part of the InfoPage component function, does not end up in any client-side code bundle.

<img width="876" height="496" alt="image" src="https://github.com/user-attachments/assets/40c47fca-709c-4919-a3cc-196564560ae3" />
Figure 16.4: The data source filename that’s included in the RSC code can’t be found on the client side

How does the content fetched from the rsc-info.json file show up on the screen then?

This gets answered if you use a different browser than Chrome or Edge. This is required since there is a bug with the Network tab in the developer tools of Chrome/Edge that leads to the response of a request being hidden under certain circumstances.

Instead, you can, for example, use Firefox, to visit the root page (/). There, click the link that’s visible on the page to navigate to the /info page. As you do so, one new HTTP request will be sent. If you inspect that request and its response (in Firefox’s browser developer tools), you’ll see the serialized RSC instructions that are returned by the server.

<img width="878" height="432" alt="image" src="https://github.com/user-attachments/assets/204ed577-eb59-431f-8573-3a35501442bd" />
Figure 16.5: Serialized instructions for client-side React are received from the server

As you can see, it’s not HTML content that’s received as a response. Instead, it’s a bunch of serialized instructions that are translated to DOM elements by React on the client side (i.e., in the browser).

Therefore, as you can tell, building and using RSCs is simple, but preparing the project to handle them is not. Instead, you need a build process that separates client and server code, and API endpoints that invoke server component functions on the server. You also need client-side code that sends requests to those API endpoints whenever the server components should be rendered.

### RSCs and Server Actions Can’t Be Used in All Projects
Thus far in this book, whenever some new React feature was introduced, you could simply use it in your React project, no matter whether it was a project created and managed by Vite or any other tool (e.g., create-react-app).

With RSCs and Server Actions, this changes. Due to the many things that must be done behind the scenes (see the previous section), even though these are features provided by React, you can’t just start using them in any React project. Instead, to unlock these features, you must have a project that’s configured to support them.

As a result, at the point of time where this book is written, RSCs and Server Actions can really only be used with the help of frameworks that integrate and actively support these features—for example, the Next.js framework.

Of course, it is technically possible to set up a project that supports both features on your own, but it requires advanced knowledge regarding backend development and build workflow configuration. Consequently, most React projects that need these features rely on frameworks like Next.js. Since the way you work with RSCs and Server Actions will always be the same, no matter in which kind of project you use them, this book will therefore ignore the custom setup part and instead focus on how to use these two core concepts.

### RSCs vs Server-side Rendering
At first sight, using RSCs may look similar to SSR React components. After all, both concepts are about running some code outside of the browser.

But even though the concepts sound similar, they are quite different.

SSR is all about rendering a component tree to HTML when a request is received. It’s about creating an initial page snapshot, in the end.

In addition, when building an interactive web application, a vital part of SSR is that the pre-rendered HTML snapshot gets hydrated on the client side—as explained in the previous chapter (see the Making Sense of Server-side Rendering (SSR) section and Figure 15.3).

As a result, **when using SSR, the entire component tree with all its component functions is evaluated on the server side as well as on the client side**. There is no split between server-side and client-side code—it’s the same app and the same component tree on both sides. For that reason, you also can’t have any server-exclusive code in your React components.

With RSCs, that changes. The code of their component functions, as explained in the previous sections, **never ends up on the client side**.

<img width="877" height="482" alt="image" src="https://github.com/user-attachments/assets/fbd2c984-f7d4-40d1-a5fe-9db311282b5b" />
Figure 16.6: RSCs are not hydrated; instead, their output is requested via HTTP requests

That’s why an SSR-enabled project doesn’t automatically support RSCs. On the other hand, you could set up a project that supports RSCs but also uses SSR for some components—components that should be pre-rendered on the server but that are also needed on the client side (e.g., because they add interactivity to the page). These types of components will be explored in the next section.

It’s also worth noting that RSCs, like server-side rendered components in SSR projects, only execute once per request. However, RSCs, unlike “normal” components rendered via SSR, can be executed on-demand while the app is running. They’re not limited to being called to create an initial page snapshot.

There is an important question, though: how can you add interactivity, and, for example, handle user input, in React apps where all components are rendered on the server? User interaction takes place in the browser, after all.

### RSCs vs Client Components
RSCs provide some convincing advantages (see the Making Sense of RSCs section), but they also introduce one potentially big problem: if all the component code “lives” and executes on the server, there’s no room for client-side interactivity.

### Not All Components Should Be RSCs
If you have a component that needs to manage some state (e.g., some shopping cart that should only be shown upon user interaction), that state and the UI must be managed and updated by client-side React. Because that was (and is) one of the main selling points of React: you can use it to build highly reactive and interactive UIs. But this goal clearly clashes with the idea of RSCs, where no component code makes it to the browser, and where components are only rendered once per request.

That’s why React allows you to define **so-called server-client boundaries** by adding the 'use client' directive at the top of files that contain component functions that should run on the client side.

<img width="787" height="419" alt="image" src="https://github.com/user-attachments/assets/d0cc9e4a-eadc-4322-8d3d-4f84263bf144" />
Figure 16.7: The ‘use client’ directive creates a boundary between server-side and client-side code

You already encountered 'use client' in the previous chapter, in the Highlighting Active Links & Using the ‘use client’ Directive section. Back then, this directive didn’t make a lot of sense. Now, with your newly gained knowledge about RSCs, the purpose behind this directive will become clearer.

With 'use client' added to a component file, the components defined in that file become client components. Client components are also pre-rendered on the server, but their code executes on the client side, too. They are hydrated, as explained in the previous chapter. Thus, unlike the code of server components, the code of client components makes it to the client side:
```
'use client';
import { useState } from 'react';
export default function Cart() {
  const [isVisible, setIsVisible] = useState(false);
  function handleCartVisibility() {
    setIsVisible((prevState) => !prevState);
  }
  return (
    <div id="cart">
      <button onClick={handleCartVisibility}>
        {isVisible ? 'Hide Cart' : 'Show Cart'}
      </button>
      {isVisible && <p>Cart Items</p>}
    </div>
  );
}
```

In this example, the Cart component is a client component because 'use client' is added at the top of the file. This is required because the Cart component uses the useState() Hook, which only works in the browser.

Whenever you add the 'use client' directive to a component file, the component functions in that file will be included in the client-side code bundle. Thus, the component functions can (and will) be executed in the browser—therefore you can use features that rely on running there, like useState() or code that should run upon user input (e.g., if a <button> was pressed).

That’s also why Next.js shows an error if you try to use a Hook in a component that’s not marked as a client component via 'use client'.

<img width="878" height="124" alt="image" src="https://github.com/user-attachments/assets/419e90db-0a82-41e0-9ea9-05ed91756969" />
Figure 16.8: Next.js complains about the usage of the useState() Hook in an RSC

This error occurs because you’re trying to build something impossible: a component that’s only evaluated on the server but that also reacts to user input and updates some state. Since the latter, as you learned in Chapter 4, Working with Events and State, will typically result in a UI update, the code needs to execute on the client side—something that’s clearly in conflict with the goal of running the component code only on the server.

Thus, 'use client' must be added whenever you have a component that needs to run in the browser.

### ‘use client’ Affects Child Components, Too!
Using the 'use client' directive in a component file has one very important implication: all nested components become client components, too—even if you don’t use 'use client' in their component files.

This is technically necessary since the JSX code of client components is re-evaluated, and all custom components used there are re-executed, every time the client component function is called again (e.g., because of some state change)—that’s something you learned in Chapter 10, Behind the Scenes of React and Optimization Opportunities.

As a result, all the components nested inside a client component must be client components themselves since their code would otherwise not be available on the client side.

<img width="878" height="497" alt="image" src="https://github.com/user-attachments/assets/a3939687-83af-4c8b-aac0-97ee05970084" />
Figure 16.9: Child components of client components become client components, too

To keep the client code bundle small and performant, it’s typically a good idea to maximize the number of server components and thus minimize the number of client components. Since nested components of client components become client components automatically, you should therefore try to move the server-client boundary (i.e., the usage of 'use client') as far down the component tree as possible. Ideally, only the leaves of your component tree use React Hooks or handle user input. Put in other words: only use 'use client' when you must and try to affect as few components with it as possible.

<img width="877" height="417" alt="image" src="https://github.com/user-attachments/assets/40994a5b-3894-4e2c-b24a-c3c61567d168" />
Figure 16.10: The majority of components are RSCs

Figure 16.10 shows an example component tree where only a small subset of all components are client components.

The question therefore is this: how can you combine and optimize the usage of server and client components in React projects that support RSCs?

### Combining RSCs and Client Components
Typically, you’ll end up with React projects where most components don’t need to be client components (therefore, they should be RSCs), but where some component functions do need to run in the browser (i.e., they do need 'use client').

You can think of 'use client' marking the point in the component tree where the component type switches from server to client component (see Figure 16.9 and Figure 16.10).

For that reason, React allows you to combine both kinds of components in the same project, though, you need to follow a couple of important rules:

- Server components may import and render client components (i.e., output a client component in their JSX code).
- Client components must not directly import and render server components that rely on server-side features.
- Client components may implicitly render server components via props (e.g., via the children prop).
To make these rules a bit less abstract, each case will be shown with a concrete example.

### Outputting Client Components in Server Components
You can use client components in the JSX code of server components without issues.

Consider the following example UserTodos component, which allows users to manage an array of to-dos that’s stored locally via localStorage:
```
'use client';
import { useEffect, useRef, useState } from 'react';
export default function UserTodos() {
  const todoRef = useRef(null);
  const [todos, setTodos] = useState([]);
  useEffect(() => {
    const storedTodos = localStorage.getItem('todos');
    setTodos(storedTodos ? JSON.parse(storedTodos) : []);
  }, []);
  function handleAddTodo(event) {
    event.preventDefault();
    const todo = todoRef.current.value.trim();
    const newTodo = {
      id: new Date().getTime(),
      text: todo,
    };
    setTodos((prevTodos) => [...prevTodos, newTodo]);
    const storedTodos = localStorage.getItem('todos');
    localStorage.setItem(
      'todos',
      JSON.stringify(
        storedTodos 
          ? [...JSON.parse(storedTodos), newTodo] 
          : [newTodo]
      )
    );
  }
  return (
    <>
      <form onSubmit={handleAddTodo}>
        <input type="text" placeholder="Your to-do" ref={todoRef} />
        <button type="submit">Add</button>
      </form>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}
```

Since localStorage (a browser API), refs, state (todos via useState()), and event listeners (submit via onSubmit) are used, this must be a client component. That’s why 'use client' is added at the top of the file.

However, this component can be used in a server component without issues:
```
import UserTodos from '../components/UserTodos';
export default function Home() {
  return (
    <main>
      <h1>Manage your to-dos with ease!</h1>
      <UserTodos />
    </main>
  );
}
```

That’s possible because client components can also be rendered on the server—they’re just not exclusive to that environment (unlike RSCs, which are). Put in other words: client components are rendered on the server like all components were in SSR projects that do not support RSCs (e.g., the Vite-based SSR-enabled project from the previous section). **An initial snapshot is rendered upon the first request, thereafter client-side React takes over and hydrates the component.**

#### Note

In the preceding example, data is loaded from localStorage via useEffect(). This is done to ensure that the code runs on the server. Since localStorage is not available there, accessing it without wrapping with useEffect() would cause an error.

Since useEffect() is ignored on the server, it’s a safe way of using browser-exclusive APIs.

### Outputting Server Components in Client Components
As already mentioned in the ‘use client’ Affects Child Components, Too! section, you can’t import server components into client components and render them there.

Though, in many situations, you’ll not get an error. For example, you might have a client-side Cart component defined like this:
```
'use client';
import { useState } from 'react';
import CartItem from './CartItem';
export default function Cart() {
  const [isVisible, setIsVisible] = useState(false);
  function handleCartVisibility() {
    setIsVisible((prevState) => !prevState);
  }
  return (
    <div id="cart">
      <button onClick={handleCartVisibility}>
        {isVisible ? 'Hide Cart' : 'Show Cart'}
      </button>
      {isVisible && (
        <ul>
          <CartItem title={'Book'} quantity={1} />
          <CartItem title={'Pen'} quantity={2} />
          <CartItem title={'Pencil'} quantity={5} />
        </ul>
      )}
    </div>
  );
}
```

Unlike Cart, the CartItem component function might be a server component (i.e., it’s not marked via 'use client'):
```
export default function CartItem({ title, quantity }) {
  return (
    <li>
      <article>
        <h2>{title}</h2>
        <p>Quantity: {quantity}</p>
      </article>
    </li>
  );
}
```

This code works because the component that used to be a server component (CartItem) simply becomes a client component once it is imported and used in a client component file.

You will, however, face an error message if you’re trying to import and use a server component that uses server component-specific features, like a Node.js API or async/await.

For example, the following adjusted DynamicCartItem component tries to use Node’s fs package to load a cart item from a file:
```
import fs from 'node:fs/promises';
export default async function DyncamicCartItem({ id }) {
  const data = await fs.readFile(`data/cart.json`, 'utf8');
  const storedCart = JSON.parse(data);
  const cartItem = storedCart.find((item) => item.id === id);
  return (
    <li>
      <article>
        <h2>{cartItem.title}</h2>
        <p>Quantity: {cartItem.quantity}</p>
      </article>
    </li>
  );
}
```
Importing and using this component in the Cart component will cause an error.

Trying to run this code will lead to an error message being shown on the screen because React fails to automatically convert CartItem to a client component (due to the usage of RSC-exclusive features). Therefore, it’ll complain about some server-side code (e.g., some Node.js API) you’re trying to use on the client side.

Hence, in situations like this, you’ll need to restructure your application to end up with a valid component combination again. For example, by passing server components as props to client components, instead of directly importing and rendering them.

### Rendering Server Components via Props
You can’t import and use server components that perform some server-side exclusive operation (like using Node.js APIs) in client components.

But you can change your client component code to not directly import and use the server component. Instead, you can expect to get a server component as a prop—for example, via the special children prop about which you learned in Chapter 3, Components and Props:
```
'use client';
import { useState } from 'react';
export default function Cart({ children }) {
  const [isVisible, setIsVisible] = useState(false);
  function handleCartVisibility() {
    setIsVisible((prevState) => !prevState);
  }
  return (
    <div id="cart">
      <button onClick={handleCartVisibility}>
        {isVisible ? 'Hide Cart' : 'Show Cart'}
      </button>
      {isVisible && <ul>{children}</ul>}
    </div>
  );
}
```

This adjusted Cart component is still a client component. However, since it no longer directly imports and renders the DynamicCartItem server component, React is happy.

Instead, the DynamicCartItem component is now imported and output in the Home component like this:
```
import DyncamicCartItem from '../components/DynamicCartItem';
import Cart from '../components/Cart';
export default function Home() {
  return (
    <>
      <header>
        <Cart>
          <DyncamicCartItem id={1} />
          <DyncamicCartItem id={2} />
          <DyncamicCartItem id={3} />
        </Cart>
      </header>
      <main>
        <h1>Some dummy app</h1>
      </main>
    </>
  );
}
```

The DynamicCartItem elements are passed as a value for the children prop to the Cart component.

This might be unintuitive at first but it’s vital to understand that this works because the DynamicCartItem components are now rendered as part of another server component—the Home component. It’s the result of that rendering process that’s then passed as a value to the Cart component. That component therefore does not include the DynamicCartItem component in its part of the component tree. Instead, both Cart and DynamicCartItem are direct children of the Home component.

The overall application component tree would look like this:

<img width="877" height="308" alt="image" src="https://github.com/user-attachments/assets/ead6980b-45d7-4070-a192-1b347635b32f" />

Figure 16.12: DynamicCartItem and Cart are both direct child components of the Home component

Even though, in the finished UI, it might look as if the DynamicCartItem is a child of Cart, technically, it’s not.

It’s key to understand that wrapping a component with another component (<Cart><DynamicCartItem /></Cart>) leads to a different component tree structure than rendering a component inside another component.

This is therefore a pattern that can be useful in situations where you might need to include a server component in a client component.

Overall, you are able to combine RSCs and client components as needed. Furthermore, Next.js also provides some additional features that can help with RSCs and data fetching via RSCs.

### Advanced Data Fetching with Next.js
As mentioned before, in the Making Sense of RSCs section, data fetching via RSCs offers various advantages compared to data fetching in client components. You don’t have to use useEffect() to send HTTP requests to separate backend APIs, you can directly reach out to a database, you can use async/await, and so on. Therefore, it’s absolutely recommended to fetch data via RSCs whenever possible.

When working with Next.js, RSC-based data fetching becomes even easier because Next.js helps with showing fallback content while you’re waiting for data to arrive.

### Managing Loading States with Next.js
When working with Next.js (with the App Router), you can define loading.js files inside the app/ folder to set up components that will be rendered while sibling or nested server components are loading data. Next.js determines whether a component is loading data or not by checking whether it returns a Promise that hasn’t resolved yet.

#### Note

The next chapter will dive even deeper into handling loading states and showing fallback content. It will explore React’s Suspense feature, which allows for granular loading state management as data streams in.

Consider this example GoalsPage component, which fetches data from a file:

```
import fs from 'node:fs/promises';
async function fetchGoals() {
  await new Promise((resolve) => setTimeout(resolve, 3000)); // delay
  const goals = await fs.readFile('./data/user-goals.json', 'utf-8');
  return JSON.parse(goals);
}
export default async function GoalsPage() {
  const fetchedGoals = await fetchGoals();
  return (
    <>
    <h1>Top User Goals</h1>
    <ul>
      {fetchedGoals.map((goal) => (
        <li key={goal}>{goal}</li>
      ))}
    </ul>
    </>
  );
}
```

The function (fetchGoals()) that performs the actual data fetching has a delay built-in to simulate a slow database or network connection.

Without a loading.js file added to the project, the user will stare at a blank or outdated page for a couple of seconds before the requested page is rendered.

<img width="877" height="258" alt="image" src="https://github.com/user-attachments/assets/7d6017ab-9151-4fc6-aa1c-ac11c5a48328" />

Figure 16.13: After clicking the link, it takes three seconds for the new page to load

This behavior occurs because the new page is not ready yet and can’t be rendered since it’s still fetching data.

To improve the user experience, a loading.js file can be added next to the slow app/goals/page.js file (or, if necessary, in some parent folder, since loading.js will also display its content for child routes).

Inside the newly created app/goals/loading.js file, a regular React component is created. Like all components in Next.js projects, this is an RSC by default:
```
export default function LoadingGoals() {
  return <p id="fallback">Loading user goals, please wait...</p>;
}
```

The component name (LoadingGoals) does not matter. But this component now ensures that the Loading user goals, please wait… fallback text is shown on the screen while the user waits for the GoalsPage to load and render.

Of course, you can show any fallback content of your choice—it doesn’t have to be some simple text as in this example.

Therefore, when working with Next.js, adding loading.js files to define fallback components can tremendously improve the experience of your website users.

Besides fetching data, many React apps also need to change data at some point.

### From Data Fetching to Data Mutations
At this point, you have learned a lot about RSCs, client components, and how they can (and cannot) work together. In the Making Sense of RSCs section, you also learned about some advantages offered by RSCs.

Of course, you also might want to change data, though—not just load and display it.

### Handling Data Mutations with Server Actions
React does not just provide support for RSCs; it also allows you to add so-called Server Actions to your applications.

Server Actions build up on the same idea as client (form) actions, which were introduced and explained in Chapter 9, Handling User Input & Forms with Form Actions. However, Server Actions, as their name implies, will execute on the server side, not on the client side.

Hence, you can use Server Actions to retrieve submitted user input on the server and process it there. For example, you could store the submitted data in a file or database.

Consequently, Server Actions are an important building block when aiming to build fully integrated fullstack React applications. Typically, data fetching alone is not enough, which is why the Server Actions feature exists. By having both, RSCs and Server Actions, you’re able to fetch and mutate data on the server, while still enabling interactive client-side user experiences where needed.

### Unlocking Server Actions in React Projects
Like RSCs, you can’t use Server Actions in all React projects. Instead, a special project setup is required to use this feature. For example, Next.js projects support Server Actions out of the box (when using the App Router). Just as with RSCs, you can think of Next.js doing the following things:

- The build workflow and bundling process separate the code that belongs to Server Actions so that it doesn’t end up in the client-side bundle.
- Next.js sets up API endpoints that trigger the Server Action functions and respond with any return values defined in those functions.
- Next.js calls these endpoints when needed (e.g., when submitting a form that’s connected to a Server Action—as shown in the next section).
Therefore, Server Actions, like RSCs, can be tricky to support in custom projects that do not use Next.js. It’s absolutely possible to create custom projects that provide support for both Server Actions and RSCs, but it’s not trivial.

Thankfully, using Server Actions (in projects that support them) is not complicated, though.

### Defining and Triggering Server Actions
As mentioned in the Handling Data Mutations with Server Actions section, Server Actions are very similar to the client form actions you already know from Chapter 9.

But there are two key differences that must be considered when creating a Server Action:

- A Server Action function must be asynchronous— (i.e., it must use async/await). There are no synchronous Server Actions.
- Inside the Server Action function, at the very beginning of the function body, you must add the 'use server' directive.
A valid Server Action can therefore be defined and used in a component like this:

```
export default function UserFeedback() {
  async function saveFeedback(formData) {
    'use server';
    const feedback = formData.get('feedback');
    console.log(feedback);
  }
  return (
    <form action={saveFeedback}>
      <p>
        <label htmlFor="feedback">Your feedback</label>
        <textarea id="feedback" name="feedback" rows={3} />
      </p>
      <p><button>Submit</button></p>
    </form>
  );
}
```

As you can see, besides the fact that it must be asynchronous and that it uses the 'use server' directive, this action function looks like the ones you saw in Chapter 9. It receives a formData object that will be provided by React when the form is submitted, and you set the action function as a value for the action prop on a <form> element.

As mentioned in the previous section, if you were to search for this code in the code files downloaded by the browser, you wouldn’t find it—this code really only runs on the server side.

#### Note

The UserFeedback component from the previous example is an RSC.

If you think about it, this might be strange, though. After all, this component does handle some user input and interaction. Why does it work without 'use client' then?

Because Server Actions (bound to the <form>'s action prop) are special. React explicitly supports this pattern inside of RSCs. 'use client' is indeed required for any other kind of user input handling (e.g., if you rely on the onSubmit or onChange props). But binding Server Actions via the action prop is supported.

Furthermore, it’s important to understand that the 'use server' directive only exists to mark actions as Server Actions. You, for example, can’t use it to mark components as server components.

Of course, the preceding example Server Action currently only logs the input to the console. A more realistic action would probably store that data somewhere and redirect the user to some other page.

### Handling User Input & Updating the UI
Consider this updated version of the previous example:
```
import { storeFeedback } from '../lib/feedback-db';
function UserFeedback() {
  async function saveFeedback(formData) {
    'use server';
    const feedback = formData.get('feedback');
    storeFeedback(feedback);
  }
  return (
    <form action={saveFeedback}>
      <p>
        <label htmlFor="feedback">Your feedback</label>
        <textarea id="feedback" name="feedback" rows={3} />
      </p>
      <p><button>Submit</button></p>
    </form>
  );
}
```

The `saveFeedback()` Server Action now stores the extracted feedback via the `storeFeedback()` function.

This function is defined like this:
```
import fs from 'node:fs/promises';
export async function storeFeedback(text) {
  const storedFeedback = await fs.readFile('data/user-feedback.json');
  const feedback = JSON.parse(storedFeedback);
  feedback.push({ id: new Date().getTime(), text });
  await fs.writeFile(
    'data/user-feedback.json', 
    JSON.stringify(feedback)
  );
}
```

In a real app, data might be stored in a database. Here, in this simple example, it’s simply stored in a user-feedback.json file that’s part of the overall Next.js project.

As you can tell, just as you can directly reach out to a file or database from inside an RSC, you are able to directly edit a file or send a database query from inside a Server Action.

You can also update the UI by programmatically navigating the user to a different page thereafter. In a Next.js application, you can use the redirect() function provided by Next.js to trigger such a navigation action—for example, right after storing the submitted feedback text:

```
import { redirect } from 'next/navigation';
import { storeFeedback } from '../lib/feedback-db';
export default function UserFeedback() {
  async function saveFeedback(formData) {
    'use server';
    const feedback = formData.get('feedback');
    await storeFeedback(feedback);
    redirect('/thanks')
  }
  // same JSX code as before, hence omitted
}
```

This is a very common pattern when building fullstack applications since you often want to navigate your website users to a different page once they have submitted data.

But you can also use a different pattern and update the UI that contains the form, based on the form submission.

Server Actions and useActionState()
You might remember the useActionState() Hook from Chapter 9, Handling User Input & Forms with Form Actions. This Hook can be used to derive some component state from a (form) action. That state, in turn, can be used to update the UI based on the result of the action.

Since a Server Action is a special kind of form action, you can use that same Hook to update the UI based on your Server Action and its returned values.

For example, you could try using useActionState() in the UserFeedback component like this:
```
import { useActionState } from 'react';
import { redirect } from 'next/navigation';
import { storeFeedback } from '../lib/feedback-db';
import FeedbackForm from './FeedbackForm';
export default function UserFeedback() {
  async function saveFeedback(prevState, formData) {
    'use server';
    const feedback = formData.get('feedback');
    if (!feedback || feedback.trim() === '') {
      return { error: 'Please provide some feedback!' };
    }
    await storeFeedback(feedback);
    redirect('/thanks');
  }
  const [formState, formAction] = useActionState(saveFeedback, {
    error: null,
  });
  return (
    <form action={formAction}>
      <p>
        <label htmlFor="feedback">Your feedback</label>
        <textarea id="feedback" name="feedback" rows={3} />
      </p>
      {formState.error && <p id="error">{formState.error}</p>}
      <p>
        <button>Submit</button>
      </p>
    </form>
  );
}
```

